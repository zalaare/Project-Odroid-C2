From 0bb1a7f2c070e0d121a72074f2b229046c57d055 Mon Sep 17 00:00:00 2001
From: "d.odintsov" <d.odintsov@traviangames.com>
Date: Mon, 18 Jan 2016 14:18:26 +0100
Subject: [PATCH 01/10] Initial commit transferring files from 15.2

---
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp  | 175 ++++
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.h    |  44 +
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp | 585 +++++++++++++
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h   |  64 ++
 .../dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp     | 912 +++++++++++++++++++++
 .../cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.h | 167 ++++
 xbmc/linux/LinuxV4l2Sink.cpp                       | 311 +++++++
 xbmc/linux/LinuxV4l2Sink.h                         |  71 ++
 xbmc/windowing/egl/EGLNativeTypeFbdev.cpp          | 196 +++++
 xbmc/windowing/egl/EGLNativeTypeFbdev.h            |  68 ++
 xbmc/windowing/egl/EGLNativeTypeHybris.cpp         | 279 +++++++
 xbmc/windowing/egl/EGLNativeTypeHybris.h           |  77 ++
 12 files changed, 2949 insertions(+)
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.h
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.h
 create mode 100644 xbmc/linux/LinuxV4l2Sink.cpp
 create mode 100644 xbmc/linux/LinuxV4l2Sink.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeFbdev.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeFbdev.h
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeHybris.cpp
 create mode 100644 xbmc/windowing/egl/EGLNativeTypeHybris.h

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp
new file mode 100644
index 0000000..3ce53f5
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp
@@ -0,0 +1,175 @@
+#include "system.h"
+
+#ifndef THIS_IS_NOT_XBMC
+  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
+    #include "config.h"
+  #endif
+  #include "DVDClock.h"
+  #include "DVDStreamInfo.h"
+  #include "AMLCodec.h"
+  #include "utils/AMLUtils.h"
+  #include "utils/BitstreamConverter.h"
+  #include "utils/log.h"
+#endif
+
+#include "DVDVideoCodecC1.h"
+
+#include <math.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <dirent.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CDVDVideoCodecC1"
+
+CDVDVideoCodecC1::CDVDVideoCodecC1() :
+  m_Codec(NULL),
+  m_pFormatName("c1-none")
+{
+  m_bitstream = new CBitstreamConverter;
+  memzero(m_videobuffer);
+}
+
+CDVDVideoCodecC1::~CDVDVideoCodecC1()
+{
+  Dispose();
+  if (m_bitstream)
+    delete m_bitstream, m_bitstream = NULL;
+}
+
+bool CDVDVideoCodecC1::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  m_hints = hints;
+  if (m_hints.software)
+    return false;
+
+  if (!aml_permissions())
+  {
+    CLog::Log(LOGERROR, "AML: no proper permission, please contact the device vendor. Skipping codec...");
+    return false;
+  }
+
+  switch(m_hints.codec)
+  {
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
+      m_pFormatName = "c1-mpeg2";
+      break;
+    case AV_CODEC_ID_MPEG4:
+    case AV_CODEC_ID_MSMPEG4V2:
+    case AV_CODEC_ID_MSMPEG4V3:
+      m_pFormatName = "c1-mpeg4";
+      break;
+    case AV_CODEC_ID_H264:
+      m_pFormatName = "c1-h264";
+      break;
+    case AV_CODEC_ID_HEVC:
+      m_pFormatName = "c1-hevc";
+      break;
+    default:
+      CLog::Log(LOGDEBUG, "%s: Unknown hints.codec id: %d", CLASSNAME, m_hints.codec);
+      return false;
+      break;
+  }
+
+  m_bVideoConvert = m_bitstream->Open(m_hints.codec, (uint8_t*)m_hints.extradata, m_hints.extrasize, true);
+  if (m_bVideoConvert) {
+    m_hints.extrasize = m_bitstream->GetExtraSize();
+    free(m_hints.extradata);
+    m_hints.extradata = malloc(m_hints.extrasize);
+    memcpy(m_hints.extradata, m_bitstream->GetExtraData(), m_hints.extrasize);
+  }
+
+  m_Codec = new CLinuxC1Codec();
+  if (!m_Codec)
+  {
+    CLog::Log(LOGERROR, "%s: Failed to create C1 Amlogic Codec", CLASSNAME);
+    return false;
+  }
+
+  if (!m_Codec->OpenDecoder(m_hints)) {
+    CLog::Log(LOGERROR, "%s: Failed to open C1 Amlogic Codec", CLASSNAME);
+    return false;
+  }
+
+  memzero(m_videobuffer);
+
+  m_videobuffer.dts             = DVD_NOPTS_VALUE;
+  m_videobuffer.pts             = DVD_NOPTS_VALUE;
+  m_videobuffer.format          = RENDER_FMT_BYPASS;
+  m_videobuffer.color_range     = 0;
+  m_videobuffer.color_matrix    = 4;
+  m_videobuffer.iFlags          = DVP_FLAG_ALLOCATED;
+  m_videobuffer.iWidth          = m_hints.width;
+  m_videobuffer.iHeight         = m_hints.height;
+  m_videobuffer.iDisplayWidth   = m_videobuffer.iWidth;
+  m_videobuffer.iDisplayHeight  = m_videobuffer.iHeight;
+
+  if (m_hints.aspect > 0.0 && (((uint)lrint(m_videobuffer.iHeight * m_hints.aspect)) & -3) > m_videobuffer.iWidth)
+      m_videobuffer.iDisplayWidth = ((int)lrint(m_videobuffer.iHeight * m_hints.aspect)) & -3;
+  double scale = fmin(
+    (double)CDisplaySettings::Get().GetCurrentResolutionInfo().iWidth / (double)m_videobuffer.iDisplayWidth,
+    (double)CDisplaySettings::Get().GetCurrentResolutionInfo().iHeight / (double)m_videobuffer.iDisplayHeight
+  );
+  m_videobuffer.iDisplayWidth = (int)((double)m_videobuffer.iDisplayWidth * scale);
+  m_videobuffer.iDisplayHeight  = (int)((double)m_videobuffer.iDisplayHeight * scale);
+
+  CLog::Log(LOGNOTICE, "%s::%s Opened C1 Amlogic Codec. DisplayWidth: %d, DisplayHeight: %d", CLASSNAME, __func__, m_videobuffer.iDisplayWidth, m_videobuffer.iDisplayHeight);
+  return true;
+}
+
+void CDVDVideoCodecC1::Dispose(void)
+{
+  if (m_Codec)
+    m_Codec->CloseDecoder(), delete m_Codec, m_Codec = NULL;
+  if (m_videobuffer.iFlags)
+    m_videobuffer.iFlags = 0;
+}
+
+int CDVDVideoCodecC1::Decode(uint8_t *pData, int iSize, double dts, double pts)
+{
+
+  if (m_hints.ptsinvalid)
+    pts = DVD_NOPTS_VALUE;
+
+  if (pData)
+  {
+    if (m_bVideoConvert) {
+      m_bitstream->Convert(pData, iSize);
+      pData = m_bitstream->GetConvertBuffer();
+      iSize = m_bitstream->GetConvertSize();
+    }
+  }
+
+  return m_Codec->Decode(pData, iSize, dts, pts);
+}
+
+void CDVDVideoCodecC1::Reset(void)
+{
+  m_Codec->Reset();
+}
+
+bool CDVDVideoCodecC1::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  m_Codec->GetPicture(&m_videobuffer);
+  *pDvdVideoPicture = m_videobuffer;
+
+  return true;
+}
+
+void CDVDVideoCodecC1::SetDropState(bool bDrop)
+{
+}
+
+void CDVDVideoCodecC1::SetSpeed(int iSpeed)
+{
+  if (m_Codec)
+    m_Codec->SetSpeed(iSpeed);
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.h
new file mode 100644
index 0000000..925434a
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#ifndef THIS_IS_NOT_XBMC
+  #include "DVDVideoCodec.h"
+  #include "DVDStreamInfo.h"
+  #include "utils/BitstreamConverter.h"
+  #include "LinuxC1Codec.h"
+#else
+  #include "xbmcstubs.h"
+  #include "LinuxC1Codec.h"
+#endif
+
+typedef struct frame_queue {
+  double dts;
+  double pts;
+  double sort_time;
+  struct frame_queue *nextframe;
+} frame_queue;
+
+class CDVDVideoCodecC1 : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecC1();
+  virtual ~CDVDVideoCodecC1();
+
+  // Required overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose(void);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual void SetSpeed(int iSpeed);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+
+protected:
+  CLinuxC1Codec  *m_Codec;
+  const char     *m_pFormatName;
+  DVDVideoPicture m_videobuffer;
+  CDVDStreamInfo  m_hints;
+
+  CBitstreamConverter *m_bitstream;
+  bool                 m_bVideoConvert;
+};
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp
new file mode 100644
index 0000000..07743a2
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp
@@ -0,0 +1,585 @@
+#include "system.h"
+
+#ifndef THIS_IS_NOT_XBMC
+  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
+    #include "config.h"
+  #endif
+  #include "DVDDemuxers/DVDDemux.h"
+  #include "DVDStreamInfo.h"
+  #include "DVDClock.h"
+  #include "guilib/GraphicContext.h"
+  #include "DVDCodecs/DVDCodecs.h"
+  #include "DVDCodecs/DVDCodecUtils.h"
+  #include "settings/Settings.h"
+  #include "settings/DisplaySettings.h"
+  #include "settings/AdvancedSettings.h"
+  #include "utils/log.h"
+#endif
+
+#include "DVDVideoCodecMFC.h"
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <dirent.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CDVDVideoCodecMFC"
+
+CDVDVideoCodecMFC::CDVDVideoCodecMFC() : CDVDVideoCodec() {
+
+  m_iDecoderHandle = NULL;
+  m_iConverterHandle = NULL;
+  m_MFCOutput = NULL;
+  m_MFCCapture = NULL;
+  m_FIMCOutput = NULL;
+  m_FIMCCapture = NULL;
+
+  m_Buffer = NULL;
+  m_BufferNowOnScreen = NULL;
+
+  memzero(m_videoBuffer);
+
+}
+
+CDVDVideoCodecMFC::~CDVDVideoCodecMFC() {
+
+  Dispose();
+
+}
+
+bool CDVDVideoCodecMFC::OpenDevices() {
+  DIR *dir;
+
+  if ((dir = opendir ("/sys/class/video4linux/")) != NULL) {
+    struct dirent *ent;
+    while ((ent = readdir (dir)) != NULL) {
+      if (strncmp(ent->d_name, "video", 5) == 0) {
+        char *p;
+        char name[64];
+        char devname[64];
+        char sysname[64];
+        char drivername[32];
+        char target[1024];
+        int ret;
+
+        snprintf(sysname, 64, "/sys/class/video4linux/%s", ent->d_name);
+        snprintf(name, 64, "/sys/class/video4linux/%s/name", ent->d_name);
+
+        FILE* fp = fopen(name, "r");
+        if (fgets(drivername, 32, fp) != NULL) {
+          p = strchr(drivername, '\n');
+          if (p != NULL)
+            *p = '\0';
+        } else {
+          fclose(fp);
+          continue;
+        }
+        fclose(fp);
+
+        ret = readlink(sysname, target, sizeof(target));
+        if (ret < 0)
+          continue;
+        target[ret] = '\0';
+        p = strrchr(target, '/');
+        if (p == NULL)
+          continue;
+
+        sprintf(devname, "/dev/%s", ++p);
+
+        if (!m_iDecoderHandle && strstr(drivername, "mfc") != NULL && strstr(drivername, "dec") != NULL) {
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > -1) {
+            struct v4l2_capability cap;
+            memzero(cap);
+            if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == 0)
+              if (cap.capabilities & V4L2_CAP_STREAMING &&
+                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
+                m_iDecoderHandle = new V4l2Device;
+                m_iDecoderHandle->device = fd;
+                strcpy(m_iDecoderHandle->name, drivername);
+                CLog::Log(LOGDEBUG, "%s::%s - MFC Found %s %s", CLASSNAME, __func__, drivername, devname);
+                struct v4l2_format fmt;
+                memzero(fmt);
+                fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+                fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+                if (ioctl(fd, VIDIOC_TRY_FMT, &fmt) == 0) {
+                  CLog::Log(LOGDEBUG, "%s::%s - Direct decoding to untiled picture on device %s is supported, no conversion needed", CLASSNAME, __func__, m_iDecoderHandle->name);
+                  delete m_iConverterHandle;
+                  m_iConverterHandle = NULL;
+                  return true;
+                }
+              }
+          }
+          if (!m_iDecoderHandle)
+            close(fd);
+        }
+        if (!m_iConverterHandle && strstr(drivername, "fimc") != NULL && strstr(drivername, "m2m") != NULL) {
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > -1) {
+            struct v4l2_capability cap;
+            memzero(cap);
+            if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == 0)
+              if (cap.capabilities & V4L2_CAP_STREAMING &&
+                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
+                m_iConverterHandle = new V4l2Device;
+                m_iConverterHandle->device = fd;
+                strcpy(m_iConverterHandle->name, drivername);
+                CLog::Log(LOGDEBUG, "%s::%s - FIMC Found %s %s", CLASSNAME, __func__, drivername, devname);
+              }
+          }
+          if (!m_iConverterHandle)
+            close(fd);
+        }
+        if (m_iDecoderHandle && m_iConverterHandle) {
+          closedir (dir);
+          return true;
+        }
+      }
+    }
+    closedir (dir);
+  }
+
+  return false;
+
+}
+
+void CDVDVideoCodecMFC::Dispose() {
+
+  CLog::Log(LOGDEBUG, "%s::%s - Starting cleanup", CLASSNAME, __func__);
+
+  delete m_BufferNowOnScreen;
+  delete m_Buffer;
+
+  m_Buffer = NULL;
+  m_BufferNowOnScreen = NULL;
+
+  delete m_FIMCCapture;
+  delete m_FIMCOutput;
+  delete m_MFCCapture;
+  delete m_MFCOutput;
+
+  m_MFCOutput = NULL;
+  m_MFCCapture = NULL;
+  m_FIMCOutput = NULL;
+  m_FIMCCapture = NULL;
+
+  if (m_iConverterHandle) {
+    close(m_iConverterHandle->device);
+    delete m_iConverterHandle;
+    m_iConverterHandle = NULL;
+  }
+
+  if (m_iDecoderHandle) {
+    close(m_iDecoderHandle->device);
+    delete m_iDecoderHandle;
+    m_iDecoderHandle = NULL;
+  }
+
+}
+
+bool CDVDVideoCodecMFC::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) {
+  struct v4l2_format fmt;
+  struct v4l2_crop crop;
+  struct V4l2SinkBuffer sinkBuffer;
+  V4l2Device *finalSink = NULL;
+  int finalFormat = -1;
+  int resultVideoWidth;
+  int resultVideoHeight;
+  int resultLineSize;
+  unsigned int extraSize = 0;
+  uint8_t *extraData = NULL;
+
+  m_hints = hints;
+  if (m_hints.software)
+    return false;
+
+  Dispose();
+
+  m_Buffer = new V4l2SinkBuffer();
+  m_BufferNowOnScreen = new V4l2SinkBuffer();
+  m_BufferNowOnScreen->iIndex = -1;
+  m_bVideoConvert = false;
+  m_bDropPictures = false;
+  memzero(m_videoBuffer);
+
+  if (!OpenDevices()) {
+    CLog::Log(LOGERROR, "%s::%s - No Exynos MFC Decoder/Converter found", CLASSNAME, __func__);
+    return false;
+  }
+
+  m_bVideoConvert = m_converter.Open(m_hints.codec, (uint8_t *)m_hints.extradata, m_hints.extrasize, true);
+
+  if(m_bVideoConvert) {
+    if(m_converter.GetExtraData() != NULL && m_converter.GetExtraSize() > 0) {
+      extraSize = m_converter.GetExtraSize();
+      extraData = m_converter.GetExtraData();
+    }
+  } else {
+    if(m_hints.extrasize > 0 && m_hints.extradata != NULL) {
+      extraSize = m_hints.extrasize;
+      extraData = (uint8_t*)m_hints.extradata;
+    }
+  }
+
+  // Test what formats we can get finally
+  // If converter is present, it is our final sink
+  (m_iConverterHandle) ? finalSink = m_iConverterHandle : finalSink = m_iDecoderHandle;
+  // Test NV12 2 Planes Y/CbCr
+  memzero(fmt);
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+  if (ioctl(finalSink->device, VIDIOC_TRY_FMT, &fmt) == 0)
+    finalFormat = V4L2_PIX_FMT_NV12M;
+  memzero(fmt);
+/*
+  // Test YUV420 3 Planes Y/Cb/Cr
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420M;
+  if (ioctl(finalSink->device, VIDIOC_TRY_FMT, &fmt) == 0)
+    finalFormat = V4L2_PIX_FMT_YUV420M;
+*/
+
+  // No suitable output formats available
+  if (finalFormat < 0) {
+    CLog::Log(LOGERROR, "%s::%s - No suitable format on %s to convert to found", CLASSNAME, __func__, finalSink->name);
+    return false;
+  }
+
+  // Create MFC Output sink (the one where encoded frames are feed)
+  m_MFCOutput = new CLinuxV4l2Sink(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+  memzero(fmt);
+  switch(m_hints.codec)
+  {
+    case AV_CODEC_ID_VC1:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G;
+      m_name = "mfc-vc1";
+      break;
+    case AV_CODEC_ID_MPEG1VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG1;
+      m_name = "mfc-mpeg1";
+      break;
+    case AV_CODEC_ID_MPEG2VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG2;
+      m_name = "mfc-mpeg2";
+      break;
+    case AV_CODEC_ID_MPEG4:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG4;
+      m_name = "mfc-mpeg4";
+      break;
+    case AV_CODEC_ID_H263:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H263;
+      m_name = "mfc-h263";
+      break;
+    case AV_CODEC_ID_H264:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;
+      m_name = "mfc-h264";
+      break;
+    default:
+      return false;
+      break;
+  }
+  fmt.fmt.pix_mp.plane_fmt[0].sizeimage = BUFFER_SIZE;
+  // Set encoded format
+  if (!m_MFCOutput->SetFormat(&fmt))
+    return false;
+  // Init with number of input buffers predefined
+  if (!m_MFCOutput->Init(INPUT_BUFFERS))
+    return false;
+
+  // Get empty buffer to fill
+  if (!m_MFCOutput->GetBuffer(&sinkBuffer))
+    return false;
+  // Fill it with the header
+  sinkBuffer.iBytesUsed[0] = extraSize;
+  memcpy(sinkBuffer.cPlane[0], extraData, extraSize);
+  // Enqueue buffer
+  if (!m_MFCOutput->PushBuffer(&sinkBuffer))
+    return false;
+
+  // Create MFC Capture sink (the one from which decoded frames are read)
+  m_MFCCapture = new CLinuxV4l2Sink(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+  memzero(fmt);
+  // If there is no converter set output format on the MFC Capture sink
+  if (!m_iConverterHandle) {
+    fmt.fmt.pix_mp.pixelformat = finalFormat;
+    if (!m_MFCCapture->SetFormat(&fmt))
+        return false;
+  }
+
+  // Turn on MFC Output with header in it to initialize MFC with all we just setup
+  m_MFCOutput->StreamOn(VIDIOC_STREAMON);
+
+  // Initialize MFC Capture
+  if (!m_MFCCapture->Init(0))
+    return false;
+  // Queue all buffers (empty) to MFC Capture
+  m_MFCCapture->QueueAll();
+
+  // Read the format of MFC Capture
+  if (!m_MFCCapture->GetFormat(&fmt))
+    return false;
+  // Size of resulting picture coming out of MFC
+  // It will be aligned by 16 since the picture is tiled
+  // We need this to know where to split buffer line by line
+  resultLineSize = fmt.fmt.pix_mp.width;
+  // Get MFC capture crop settings
+  if (!m_MFCCapture->GetCrop(&crop))
+    return false;
+  // This is the picture boundaries we are interested in, everything outside is alignement because of tiled MFC output
+  resultVideoWidth = crop.c.width;
+  resultVideoHeight = crop.c.height;
+
+  // Turn on MFC Capture
+  m_MFCCapture->StreamOn(VIDIOC_STREAMON);
+
+  // If converter is needed (we need to untile the picture from format MFC produces it)
+  if (m_iConverterHandle) {
+    // Create FIMC Output sink
+    m_FIMCOutput = new CLinuxV4l2Sink(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+    // Set the FIMC Output format to the one read from MFC
+    if (!m_FIMCOutput->SetFormat(&fmt))
+      return false;
+    // Set the FIMC Output crop to the one read from MFC
+    if (!m_FIMCOutput->SetCrop(&crop))
+      return false;
+    // Init FIMC Output and link it to buffers of MFC Capture
+    if (!m_FIMCOutput->Init(m_MFCCapture))
+      return false;
+    // Get FIMC Output crop settings
+    if (!m_FIMCOutput->GetCrop(&crop))
+      return false;
+
+    // Create FIMC Capture sink
+    m_FIMCCapture = new CLinuxV4l2Sink(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+    // Set the final picture format and the same picture dimension settings to FIMC Capture
+    // as picture crop coming from MFC (original picture dimensions)
+    memzero(fmt);
+    fmt.fmt.pix_mp.pixelformat = finalFormat;
+    fmt.fmt.pix_mp.width = crop.c.width;
+    fmt.fmt.pix_mp.height = crop.c.height;
+    fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
+    if (!m_FIMCCapture->SetFormat(&fmt))
+      return false;
+    // Init FIMC capture with number of buffers predefined
+    if (!m_FIMCCapture->Init(OUTPUT_BUFFERS))
+      return false;
+
+    // Queue all buffers (empty) to FIMC Capture
+    m_FIMCCapture->QueueAll();
+
+    // Read FIMC capture format settings
+    if (!m_FIMCCapture->GetFormat(&fmt))
+      return false;
+    resultLineSize = fmt.fmt.pix_mp.width;
+    // Read FIMC capture crop settings
+    if (!m_FIMCCapture->GetCrop(&crop))
+      return false;
+    resultVideoWidth = crop.c.width;
+    resultVideoHeight = crop.c.height;
+
+    // Turn on FIMC Output and Capture enabling the converter
+    m_FIMCOutput->StreamOn(VIDIOC_STREAMON);
+    m_FIMCCapture->StreamOn(VIDIOC_STREAMON);
+  }
+
+  m_videoBuffer.iFlags          = DVP_FLAG_ALLOCATED;
+
+  m_videoBuffer.color_range     = 0;
+  m_videoBuffer.color_matrix    = 4;
+
+  m_videoBuffer.iDisplayWidth   = resultVideoWidth;
+  m_videoBuffer.iDisplayHeight  = resultVideoHeight;
+  m_videoBuffer.iWidth          = resultVideoWidth;
+  m_videoBuffer.iHeight         = resultVideoHeight;
+
+  m_videoBuffer.data[0]         = NULL;
+  m_videoBuffer.data[1]         = NULL;
+  m_videoBuffer.data[2]         = NULL;
+  m_videoBuffer.data[3]         = NULL;
+
+  m_videoBuffer.pts             = DVD_NOPTS_VALUE;
+  m_videoBuffer.dts             = DVD_NOPTS_VALUE;
+
+  m_videoBuffer.iLineSize[0]    = resultLineSize;
+  m_videoBuffer.iLineSize[3]    = 0;
+
+  if (finalFormat == V4L2_PIX_FMT_NV12M) {
+    m_videoBuffer.format          = RENDER_FMT_NV12;
+    m_videoBuffer.iLineSize[1]    = resultLineSize;
+    m_videoBuffer.iLineSize[2]    = 0;
+  } else if (finalFormat == V4L2_PIX_FMT_YUV420M) {
+    /*
+     Due to BUG in MFC v8 (-XU3) firmware the Y plane of the picture has the right line size,
+     but the U and V planes line sizes are actually halves of Y plane line size padded to 32
+     This is pure workaround for -XU3 MFCv8 firmware "MFC v8.0, F/W: 14yy, 01mm, 13dd (D)
+     Seems that only MPEG2 is affected
+    */
+    // Only on -XU3 there are no converter, but the output format can be YUV420
+    // So this is the easiest way to distinguish -XU3 from -U3 with FIMC
+    if (!m_iConverterHandle && m_hints.codec == AV_CODEC_ID_MPEG2VIDEO)
+      resultLineSize = resultLineSize + (32 - resultLineSize%32);
+
+    m_videoBuffer.format          = RENDER_FMT_YUV420P;
+    m_videoBuffer.iLineSize[1]    = resultLineSize >> 1;
+    m_videoBuffer.iLineSize[2]    = resultLineSize >> 1;
+  }
+
+  m_BufferNowOnScreen->iIndex = -1;
+  m_bCodecHealthy = true;
+
+  CLog::Log(LOGNOTICE, "%s::%s - MFC Setup succesfull (%dx%d, linesize %d, format 0x%x), start streaming", CLASSNAME, __func__, resultVideoWidth, resultVideoHeight, resultLineSize, finalFormat);
+
+  return true;
+
+}
+
+void CDVDVideoCodecMFC::SetDropState(bool bDrop) {
+
+  m_bDropPictures = bDrop;
+  if (m_bDropPictures)
+    m_videoBuffer.iFlags |=  DVP_FLAG_DROPPED;
+  else
+    m_videoBuffer.iFlags &= ~DVP_FLAG_DROPPED;
+
+}
+
+int CDVDVideoCodecMFC::Decode(BYTE* pData, int iSize, double dts, double pts) {
+
+  if (m_hints.ptsinvalid)
+    pts = DVD_NOPTS_VALUE;
+
+  //unsigned int dtime = XbmcThreads::SystemClockMillis();
+  debug_log(LOGDEBUG, "%s::%s - input frame iSize %d, pts %lf, dts %lf", CLASSNAME, __func__, iSize, pts, dts);
+
+  if(pData) {
+    int demuxer_bytes = iSize;
+    uint8_t *demuxer_content = pData;
+
+    if(m_bVideoConvert) {
+      m_converter.Convert(demuxer_content, demuxer_bytes);
+      demuxer_bytes = m_converter.GetConvertSize();
+      demuxer_content = m_converter.GetConvertBuffer();
+    }
+
+    m_MFCOutput->Poll(1000/3); // Wait up to 0.3 of a second for buffer availability
+    if (m_MFCOutput->GetBuffer(m_Buffer)) {
+      debug_log(LOGDEBUG, "%s::%s - Got empty buffer %d from MFC Output, filling", CLASSNAME, __func__, m_Buffer->iIndex);
+      m_Buffer->iBytesUsed[0] = demuxer_bytes;
+      memcpy((uint8_t *)m_Buffer->cPlane[0], demuxer_content, m_Buffer->iBytesUsed[0]);
+      long* longPts = (long*)&pts;
+      m_Buffer->timeStamp.tv_sec = longPts[0];
+      m_Buffer->timeStamp.tv_usec = longPts[1];
+
+      if (!m_MFCOutput->PushBuffer(m_Buffer)) {
+        m_bCodecHealthy = false;
+        return VC_FLUSHED; // MFC unrecoverable error, reset needed
+      }
+    } else {
+      if (errno == EAGAIN)
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT All buffers are queued and busy, no space for new frame to decode. Very broken situation. Current encoded frame will be lost", CLASSNAME, __func__);
+      else {
+        m_bCodecHealthy = false;
+        return VC_FLUSHED; // MFC unrecoverable error, reset needed
+      }
+    }
+  }
+
+  // Get a buffer from MFC Capture
+  if (!m_MFCCapture->DequeueBuffer(m_Buffer)) {
+    if (errno == EAGAIN)
+      return VC_BUFFER;
+    else
+      return VC_ERROR;
+  }
+
+  if (m_bDropPictures) {
+
+    CLog::Log(LOGWARNING, "%s::%s - Dropping frame with index %d", CLASSNAME, __func__, m_Buffer->iIndex);
+    // Queue it back to MFC CAPTURE since the picture is dropped anyway
+    m_MFCCapture->PushBuffer(m_Buffer);
+    return VC_DROPPED | VC_BUFFER;
+
+  }
+
+  if (m_iConverterHandle) {
+    // Push the buffer got from MFC Capture to FIMC Output (decoded from decoder to converter)
+    if (!m_FIMCOutput->PushBuffer(m_Buffer)) {
+      m_bCodecHealthy = false;
+      return VC_FLUSHED; // FIMC unrecoverable error, reset needed
+    }
+    // Get a buffer from FIMC Capture
+    if (!m_FIMCCapture->DequeueBuffer(m_Buffer)) {
+      if (errno == EAGAIN)
+        return VC_BUFFER;
+      else
+        return VC_ERROR;
+    }
+  }
+
+  // We got a new buffer to show, so we can enqeue back the buffer wich was on screen
+  if (m_BufferNowOnScreen->iIndex > -1) {
+    if (m_iConverterHandle)
+      m_FIMCCapture->PushBuffer(m_BufferNowOnScreen);
+    else
+      m_MFCCapture->PushBuffer(m_BufferNowOnScreen);
+    m_BufferNowOnScreen->iIndex = -1;
+  }
+
+  long longPts[2] = { m_Buffer->timeStamp.tv_sec, m_Buffer->timeStamp.tv_usec };
+  m_videoBuffer.data[0]         = (BYTE*)m_Buffer->cPlane[0];
+  m_videoBuffer.data[1]         = (BYTE*)m_Buffer->cPlane[1];
+  m_videoBuffer.data[2]         = (BYTE*)m_Buffer->cPlane[2];
+  m_videoBuffer.pts             = *((double*)&longPts[0]);
+
+  std::swap(m_Buffer, m_BufferNowOnScreen);
+
+  if (m_iConverterHandle && m_FIMCOutput->DequeueBuffer(m_Buffer))
+    m_MFCCapture->PushBuffer(m_Buffer);
+
+  //debug_log("Decode time: %d", XbmcThreads::SystemClockMillis() - dtime);
+  // Picture is finally ready to be processed further and more info can be enqueued
+  return VC_PICTURE | VC_BUFFER;
+
+}
+
+void CDVDVideoCodecMFC::Reset() {
+
+  if (m_bCodecHealthy) {
+    CLog::Log(LOGDEBUG, "%s::%s - Codec Reset requested, but codec is healthy, doing soft-flush", CLASSNAME, __func__);
+    m_MFCOutput->SoftRestart();
+    m_MFCCapture->SoftRestart();
+    if (!m_iConverterHandle)
+      m_BufferNowOnScreen->iIndex = -1;
+  } else {
+    CLog::Log(LOGERROR, "%s::%s - Codec Reset. Reinitializing", CLASSNAME, __func__);
+    CDVDCodecOptions options;
+    // We need full MFC/FIMC reset with device reopening.
+    // I wasn't able to reinitialize both IP's without fully closing and reopening them.
+    // There are always some clips that cause MFC or FIMC go into state which cannot be reset without close/open
+    Open(m_hints, options);
+  }
+
+}
+
+bool CDVDVideoCodecMFC::GetPicture(DVDVideoPicture* pDvdVideoPicture) {
+
+  *pDvdVideoPicture = m_videoBuffer;
+  debug_log(LOGDEBUG, "%s::%s - output frame pts %lf", CLASSNAME, __func__, m_videoBuffer.pts);
+  return true;
+
+}
+
+bool CDVDVideoCodecMFC::ClearPicture(DVDVideoPicture* pDvdVideoPicture) {
+
+  return CDVDVideoCodec::ClearPicture(pDvdVideoPicture);
+
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h
new file mode 100644
index 0000000..5e3a539
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMFC.h
@@ -0,0 +1,64 @@
+#pragma once
+
+#ifndef THIS_IS_NOT_XBMC
+  #include "DVDVideoCodec.h"
+  #include "DVDStreamInfo.h"
+  #include "utils/BitstreamConverter.h"
+  #include "xbmc/linux/LinuxV4l2Sink.h"
+#else
+  #include "xbmcstubs.h"
+  #include "LinuxV4l2Sink.h"
+#endif
+
+#ifndef V4L2_CAP_VIDEO_M2M_MPLANE
+  #define V4L2_CAP_VIDEO_M2M_MPLANE 0x00004000
+#endif
+
+#define BUFFER_SIZE        1048576 // Compressed frame size. 1080p mpeg4 10Mb/s can be >256k in size, so this is to make sure frame fits into the buffer
+                                   // For very unknown reason lesser than 1Mb buffer causes MFC to corrupt its own setup, setting inapropriate values
+#define INPUT_BUFFERS      3       // 3 input buffers. 2 is enough almost for everything, but on some heavy videos 3 makes a difference
+#define OUTPUT_BUFFERS     3       // Triple buffering for smooth output
+
+#define memzero(x) memset(&(x), 0, sizeof (x))
+
+class CDVDVideoCodecMFC : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecMFC();
+  virtual ~CDVDVideoCodecMFC();
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose();
+  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
+  virtual void Reset();
+  bool GetPictureCommon(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
+
+protected:
+  std::string m_name;
+
+  bool m_bCodecHealthy;
+
+  V4l2Device *m_iDecoderHandle;
+  V4l2Device *m_iConverterHandle;
+
+  CLinuxV4l2Sink *m_MFCCapture;
+  CLinuxV4l2Sink *m_MFCOutput;
+  CLinuxV4l2Sink *m_FIMCCapture;
+  CLinuxV4l2Sink *m_FIMCOutput;
+
+  V4l2SinkBuffer *m_Buffer;
+  V4l2SinkBuffer *m_BufferNowOnScreen;
+
+  bool m_bVideoConvert;
+  CDVDStreamInfo m_hints;
+
+  CBitstreamConverter m_converter;
+  bool m_bDropPictures;
+
+  DVDVideoPicture   m_videoBuffer;
+
+  bool OpenDevices();
+};
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
new file mode 100644
index 0000000..8f1525f
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
@@ -0,0 +1,912 @@
+#include "system.h"
+
+#ifndef THIS_IS_NOT_XBMC
+  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
+    #include "config.h"
+  #endif
+
+  #include "utils/log.h"
+#endif
+
+#include "LinuxC1Codec.h"
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CLinuxC1Codec"
+
+static int64_t get_pts_video()
+{
+  int fd = open("/sys/class/tsync/pts_video", O_RDONLY);
+  if (fd >= 0)
+  {
+    char pts_str[16];
+    int size = read(fd, pts_str, sizeof(pts_str));
+    close(fd);
+    if (size > 0)
+    {
+      unsigned long pts = strtoul(pts_str, NULL, 16);
+      debug_log(LOGDEBUG, "%s::%s get_pts_video: %lu", CLASSNAME, __func__, pts);
+      return pts;
+    }
+  }
+  CLog::Log(LOGERROR, "%s::%s get_pts_video: open /tsync/event error", CLASSNAME, __func__);
+  return -1;
+}
+
+static vformat_t codecid_to_vformat(enum AVCodecID id)
+{
+  vformat_t format;
+  switch (id)
+  {
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
+      format = VFORMAT_MPEG12;
+      break;
+    case AV_CODEC_ID_MPEG4:
+      format = VFORMAT_MPEG4;
+      break;
+    case AV_CODEC_ID_H264:
+      format = VFORMAT_H264;
+      break;
+    case AV_CODEC_ID_HEVC:
+      format = VFORMAT_HEVC;
+      break;
+    default:
+      format = VFORMAT_UNSUPPORT;
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s codecid_to_vformat, id(%d) -> vformat(%d)", CLASSNAME, __func__, (int)id, format);
+  return format;
+}
+
+static vdec_type_t codec_tag_to_vdec_type(unsigned int codec_tag)
+{
+  vdec_type_t dec_type;
+  switch (codec_tag)
+  {
+    case CODEC_TAG_COL1:
+    case CODEC_TAG_DIV3:
+    case CODEC_TAG_MP43:
+      // divx3.11
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_3;
+      break;
+    case CODEC_TAG_DIV4:
+    case CODEC_TAG_DIVX:
+      // divx4
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_4;
+      break;
+    case CODEC_TAG_XVID:
+    case CODEC_TAG_xvid:
+    case CODEC_TAG_XVIX:
+    case CODEC_TAG_DIV5:
+    case CODEC_TAG_DX50:
+    case CODEC_TAG_M4S2:
+    case CODEC_TAG_FMP4:
+    case CODEC_TAG_DIV6:
+    case CODEC_TAG_MP4V:
+    case CODEC_TAG_RMP4:
+    case CODEC_TAG_MPG4:
+    case CODEC_TAG_mp4v:
+    case AV_CODEC_ID_MPEG4:
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_5;
+      break;
+    case CODEC_TAG_AVC1:
+    case CODEC_TAG_avc1:
+    case CODEC_TAG_H264:
+    case CODEC_TAG_h264:
+    case AV_CODEC_ID_H264:
+      dec_type = VIDEO_DEC_FORMAT_H264;
+      break;
+    case AV_CODEC_ID_HEVC:
+      dec_type = VIDEO_DEC_FORMAT_HEVC;
+      break;
+
+    default:
+      dec_type = VIDEO_DEC_FORMAT_UNKNOW;
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s codec_tag_to_vdec_type, codec_tag(%d) -> vdec_type(%d)", CLASSNAME, __func__, codec_tag, dec_type);
+  return dec_type;
+}
+
+void codec_init_para(aml_generic_param *p_in, codec_para_t *p_out)
+{
+  memzero(*p_out);
+
+  p_out->has_video          = 1;
+  p_out->noblock            = p_in->noblock;
+  p_out->video_pid          = p_in->video_pid;
+  p_out->video_type         = p_in->video_type;
+  p_out->stream_type        = p_in->stream_type;
+  p_out->am_sysinfo.format  = p_in->format;
+  p_out->am_sysinfo.width   = p_in->width;
+  p_out->am_sysinfo.height  = p_in->height;
+  p_out->am_sysinfo.rate    = p_in->rate;
+  p_out->am_sysinfo.extra   = p_in->extra;
+  p_out->am_sysinfo.status  = p_in->status;
+  p_out->am_sysinfo.ratio   = p_in->ratio;
+  p_out->am_sysinfo.ratio64 = p_in->ratio64;
+  p_out->am_sysinfo.param   = p_in->param;
+}
+
+void am_packet_release(am_packet_t *pkt)
+{
+  if (pkt->buf != NULL)
+    free(pkt->buf), pkt->buf= NULL;
+  if (pkt->hdr != NULL)
+  {
+    if (pkt->hdr->data != NULL)
+      free(pkt->hdr->data), pkt->hdr->data = NULL;
+    free(pkt->hdr), pkt->hdr = NULL;
+  }
+
+  pkt->codec = NULL;
+}
+
+int check_in_pts(am_private_t *para, am_packet_t *pkt)
+{
+    int last_duration = 0;
+    static int last_v_duration = 0;
+    int64_t pts = 0;
+
+    last_duration = last_v_duration;
+
+    if (para->stream_type == AM_STREAM_ES) {
+        if ((int64_t)AV_NOPTS_VALUE != pkt->avpts) {
+            pts = pkt->avpts;
+
+            if (codec_checkin_pts(pkt->codec, pts) != 0) {
+                CLog::Log(LOGERROR, "%s::%s ERROR check in pts error!", CLASSNAME, __func__);
+                return PLAYER_PTS_ERROR;
+            }
+
+        } else if ((int64_t)AV_NOPTS_VALUE != pkt->avdts) {
+            pts = pkt->avdts * last_duration;
+
+            if (codec_checkin_pts(pkt->codec, pts) != 0) {
+                CLog::Log(LOGERROR, "%s::%s ERROR check in dts error!", CLASSNAME, __func__);
+                return PLAYER_PTS_ERROR;
+            }
+
+            last_v_duration = pkt->avduration ? pkt->avduration : 1;
+        } else {
+            if (!para->check_first_pts) {
+                if (codec_checkin_pts(pkt->codec, 0) != 0) {
+                    CLog::Log(LOGERROR, "%s::%s ERROR check in 0 to video pts error!", CLASSNAME, __func__);
+                    return PLAYER_PTS_ERROR;
+                }
+            }
+        }
+        if (!para->check_first_pts) {
+            para->check_first_pts = 1;
+        }
+    }
+    if (pts > 0)
+      pkt->lastpts = pts;
+
+    return PLAYER_SUCCESS;
+}
+
+static int write_header(am_private_t *para, am_packet_t *pkt)
+{
+    int write_bytes = 0, len = 0;
+
+    if (pkt->hdr && pkt->hdr->size > 0) {
+        if ((NULL == pkt->codec) || (NULL == pkt->hdr->data)) {
+            CLog::Log(LOGERROR, "%s::%s [write_header]codec null!", CLASSNAME, __func__);
+            return PLAYER_EMPTY_P;
+        }
+        while (1) {
+            write_bytes = codec_write(pkt->codec, pkt->hdr->data + len, pkt->hdr->size - len);
+            if (write_bytes < 0 || write_bytes > (pkt->hdr->size - len)) {
+                if (-errno != AVERROR(EAGAIN)) {
+                    CLog::Log(LOGERROR, "%s::%s ERROR:write header failed!", CLASSNAME, __func__);
+                    return PLAYER_WR_FAILED;
+                } else {
+                    continue;
+                }
+            } else {
+                len += write_bytes;
+                if (len == pkt->hdr->size) {
+                    break;
+                }
+            }
+        }
+    }
+    return PLAYER_SUCCESS;
+}
+
+int write_av_packet(am_private_t *para, am_packet_t *pkt)
+{
+  //CLog::Log(LOGDEBUG, "write_av_packet, pkt->isvalid(%d), pkt->data(%p), pkt->data_size(%d)",
+  //  pkt->isvalid, pkt->data, pkt->data_size);
+
+    int write_bytes = 0, len = 0, ret;
+    unsigned char *buf;
+    int size;
+
+    // do we need to check in pts or write the header ?
+    if (pkt->newflag) {
+        if (pkt->isvalid) {
+            ret = check_in_pts(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                CLog::Log(LOGERROR, "%s::%s check in pts failed", CLASSNAME, __func__);
+                return PLAYER_WR_FAILED;
+            }
+        }
+        if (write_header(para, pkt) == PLAYER_WR_FAILED) {
+            CLog::Log(LOGERROR, "%s::%s write header failed!", CLASSNAME, __func__);
+            return PLAYER_WR_FAILED;
+        }
+        pkt->newflag = 0;
+    }
+
+    buf = pkt->data;
+    size = pkt->data_size ;
+    if (size == 0 && pkt->isvalid) {
+        pkt->isvalid = 0;
+        pkt->data_size = 0;
+    }
+
+    while (size > 0 && pkt->isvalid) {
+        write_bytes = codec_write(pkt->codec, buf, size);
+        if (write_bytes < 0 || write_bytes > size) {
+            CLog::Log(LOGDEBUG, "%s::%s write codec data failed, write_bytes(%d), errno(%d), size(%d)", CLASSNAME, __func__, write_bytes, errno, size);
+            if (-errno != AVERROR(EAGAIN)) {
+                CLog::Log(LOGDEBUG, "write codec data failed!");
+                return PLAYER_WR_FAILED;
+            } else {
+                // adjust for any data we already wrote into codec.
+                // we sleep a bit then exit as we will get called again
+                // with the same pkt because pkt->isvalid has not been cleared.
+                pkt->data += len;
+                pkt->data_size -= len;
+                usleep(RW_WAIT_TIME);
+                CLog::Log(LOGDEBUG, "%s::%s usleep(RW_WAIT_TIME), len(%d)", CLASSNAME, __func__, len);
+                return PLAYER_SUCCESS;
+            }
+        } else {
+            // keep track of what we write into codec from this pkt
+            // in case we get hit with EAGAIN.
+            len += write_bytes;
+            if (len == pkt->data_size) {
+                pkt->isvalid = 0;
+                pkt->data_size = 0;
+                break;
+            } else if (len < pkt->data_size) {
+                buf += write_bytes;
+                size -= write_bytes;
+            } else {
+                // writing more that we should is a failure.
+                return PLAYER_WR_FAILED;
+            }
+        }
+    }
+
+    return PLAYER_SUCCESS;
+}
+
+static int h264_add_header(unsigned char *buf, int size, am_packet_t *pkt)
+{
+    if (size > HDR_BUF_SIZE)
+    {
+        free(pkt->hdr->data);
+        pkt->hdr->data = (char *)malloc(size);
+        if (!pkt->hdr->data)
+            return PLAYER_NOMEM;
+    }
+
+    memcpy(pkt->hdr->data, buf, size);
+    pkt->hdr->size = size;
+    return PLAYER_SUCCESS;
+}
+
+static int h264_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "%s::%s h264_write_header", CLASSNAME, __func__);
+
+    int ret = h264_add_header(para->extradata, para->extrasize, pkt);
+    if (ret == PLAYER_SUCCESS) {
+        pkt->codec = &para->vcodec;
+        pkt->newflag = 1;
+        ret = write_av_packet(para, pkt);
+    }
+    return ret;
+}
+
+static int hevc_add_header(unsigned char *buf, int size,  am_packet_t *pkt)
+{
+    if (size > HDR_BUF_SIZE)
+    {
+        free(pkt->hdr->data);
+        pkt->hdr->data = (char *)malloc(size);
+        if (!pkt->hdr->data)
+            return PLAYER_NOMEM;
+    }
+
+    memcpy(pkt->hdr->data, buf, size);
+    pkt->hdr->size = size;
+    return PLAYER_SUCCESS;
+}
+
+static int hevc_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    int ret = -1;
+
+    if (para->extradata) {
+      ret = hevc_add_header(para->extradata, para->extrasize, pkt);
+    }
+    if (ret == PLAYER_SUCCESS) {
+      pkt->codec = &para->vcodec;
+      pkt->newflag = 1;
+      ret = write_av_packet(para, pkt);
+    }
+    return ret;
+}
+
+static int divx3_data_prefeeding(am_packet_t *pkt, unsigned w, unsigned h)
+{
+    unsigned i = (w << 12) | (h & 0xfff);
+    unsigned char divx311_add[10] = {
+        0x00, 0x00, 0x00, 0x01,
+        0x20, 0x00, 0x00, 0x00,
+        0x00, 0x00
+    };
+    divx311_add[5] = (i >> 16) & 0xff;
+    divx311_add[6] = (i >> 8) & 0xff;
+    divx311_add[7] = i & 0xff;
+
+    if (pkt->hdr->data) {
+        memcpy(pkt->hdr->data, divx311_add, sizeof(divx311_add));
+        pkt->hdr->size = sizeof(divx311_add);
+    } else {
+        CLog::Log(LOGERROR, "%s::%s [divx3_data_prefeeding]No enough memory!", CLASSNAME, __func__);
+        return PLAYER_FAILED;
+    }
+    return PLAYER_SUCCESS;
+}
+
+static int divx3_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "%s::%s divx3_write_header", CLASSNAME, __func__);
+
+    divx3_data_prefeeding(pkt, para->video_width, para->video_height);
+
+    pkt->codec = &para->vcodec;
+    pkt->newflag = 1;
+    write_av_packet(para, pkt);
+    return PLAYER_SUCCESS;
+}
+
+static int m4s2_dx50_mp4v_add_header(unsigned char *buf, int size,  am_packet_t *pkt)
+{
+    if (size > pkt->hdr->size) {
+        free(pkt->hdr->data), pkt->hdr->data = NULL;
+        pkt->hdr->size = 0;
+
+        pkt->hdr->data = (char*)malloc(size);
+        if (!pkt->hdr->data) {
+            CLog::Log(LOGERROR, "%s::%s [m4s2_dx50_add_header] NOMEM!", CLASSNAME, __func__);
+            return PLAYER_FAILED;
+        }
+    }
+
+    pkt->hdr->size = size;
+    memcpy(pkt->hdr->data, buf, size);
+
+    return PLAYER_SUCCESS;
+}
+
+static int m4s2_dx50_mp4v_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "%s::%s m4s2_dx50_mp4v_write_header", CLASSNAME, __func__);
+
+    int ret = m4s2_dx50_mp4v_add_header(para->extradata, para->extrasize, pkt);
+    if (ret == PLAYER_SUCCESS) {
+        pkt->codec = &para->vcodec;
+        pkt->newflag = 1;
+        ret = write_av_packet(para, pkt);
+    }
+    return ret;
+}
+
+static int mpeg_add_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "%s::%s mpeg_add_header", CLASSNAME, __func__);
+
+#define STUFF_BYTES_LENGTH     (256)
+
+    int size;
+    unsigned char packet_wrapper[] = {
+        0x00, 0x00, 0x01, 0xe0,
+        0x00, 0x00,                                /* pes packet length */
+        0x81, 0xc0, 0x0d,
+        0x20, 0x00, 0x00, 0x00, 0x00, /* PTS */
+        0x1f, 0xff, 0xff, 0xff, 0xff, /* DTS */
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+    };
+
+    size = para->extrasize + sizeof(packet_wrapper);
+    packet_wrapper[4] = size >> 8 ;
+    packet_wrapper[5] = size & 0xff ;
+    memcpy(pkt->hdr->data, packet_wrapper, sizeof(packet_wrapper));
+    size = sizeof(packet_wrapper);
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]wrapper size=%d\n",__LINE__,size);
+    memcpy(pkt->hdr->data + size, para->extradata, para->extrasize);
+    size += para->extrasize;
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]wrapper+seq size=%d\n",__LINE__,size);
+    memset(pkt->hdr->data + size, 0xff, STUFF_BYTES_LENGTH);
+    size += STUFF_BYTES_LENGTH;
+    pkt->hdr->size = size;
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]hdr_size=%d\n",__LINE__,size);
+
+    pkt->codec = &para->vcodec;
+    pkt->newflag = 1;
+    return write_av_packet(para, pkt);
+
+}
+
+int pre_header_feeding(am_private_t *para, am_packet_t *pkt)
+{
+    int ret;
+
+    if (pkt->hdr == NULL) {
+        pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+        pkt->hdr->data = (char*)malloc(HDR_BUF_SIZE);
+        if (!pkt->hdr->data) {
+            CLog::Log(LOGERROR, "%s::%s [pre_header_feeding] NOMEM!", CLASSNAME, __func__);
+            return PLAYER_NOMEM;
+        }
+    }
+
+    if (para->stream_type == AM_STREAM_ES) {
+        if (VFORMAT_H264 == para->video_format || VFORMAT_H264_4K2K == para->video_format) {
+            ret = h264_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if (VFORMAT_HEVC == para->video_format) {
+            ret = hevc_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if ((VFORMAT_MPEG4 == para->video_format) && (VIDEO_DEC_FORMAT_MPEG4_3 == para->video_codec_type)) {
+            ret = divx3_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if ((CODEC_TAG_M4S2 == para->video_codec_tag)
+                || (CODEC_TAG_DX50 == para->video_codec_tag)
+                || (CODEC_TAG_mp4v == para->video_codec_tag)) {
+            ret = m4s2_dx50_mp4v_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if (( AV_CODEC_ID_MPEG1VIDEO == para->video_codec_id)
+          || (AV_CODEC_ID_MPEG2VIDEO == para->video_codec_id)) {
+            ret = mpeg_add_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        }
+    }
+
+    if (pkt->hdr) {
+        if (pkt->hdr->data) {
+            free(pkt->hdr->data);
+            pkt->hdr->data = NULL;
+        }
+        free(pkt->hdr);
+        pkt->hdr = NULL;
+    }
+
+    return PLAYER_SUCCESS;
+}
+
+CLinuxC1Codec::CLinuxC1Codec() {
+  am_private = new am_private_t;
+  memzero(*am_private);
+}
+
+CLinuxC1Codec::~CLinuxC1Codec() {
+  delete am_private;
+  am_private = NULL;
+}
+
+bool CLinuxC1Codec::OpenDecoder(CDVDStreamInfo &hints) {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  m_speed = DVD_PLAYSPEED_NORMAL;
+  m_1st_pts = 0;
+  m_cur_pts = 0;
+  m_cur_pictcnt = 0;
+  m_old_pictcnt = 0;
+  m_start_dts = 0;
+  m_start_pts = 0;
+  m_hints = hints;
+
+  memzero(am_private->am_pkt);
+  am_private->stream_type      = AM_STREAM_ES;
+  if (hints.width == 0 || hints.height == 0)
+    return false;
+  am_private->video_width      = hints.width;
+  am_private->video_height     = hints.height;
+  am_private->video_codec_id   = hints.codec;
+  am_private->video_codec_tag  = hints.codec_tag;
+  am_private->video_pid        = hints.pid;
+
+  // handle video ratio
+  AVRational video_ratio       = av_d2q(1, SHRT_MAX);
+  am_private->video_ratio      = ((int32_t)video_ratio.num << 16) | video_ratio.den;
+  am_private->video_ratio64    = ((int64_t)video_ratio.num << 32) | video_ratio.den;
+
+  // handle video rate
+  if (hints.rfpsrate > 0 && hints.rfpsscale != 0)
+  {
+    // check ffmpeg r_frame_rate 1st
+    am_private->video_rate = 0.5 + (float)UNIT_FREQ * hints.rfpsscale / hints.rfpsrate;
+  }
+  else if (hints.fpsrate > 0 && hints.fpsscale != 0)
+  {
+    // then ffmpeg avg_frame_rate next
+    am_private->video_rate = 0.5 + (float)UNIT_FREQ * hints.fpsscale / hints.fpsrate;
+  }
+
+  // check for 1920x1080, interlaced, 25 fps
+  // incorrectly reported as 50 fps (yes, video_rate == 1920)
+  if (hints.width == 1920 && am_private->video_rate == 1920)
+  {
+    CLog::Log(LOGDEBUG, "%s::%s video_rate exception", CLASSNAME, __func__);
+    am_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 25000;
+  }
+
+  // check for SD h264 content incorrectly reported as 60 fsp
+  // mp4/avi containers :(
+  if (hints.codec == AV_CODEC_ID_H264 && hints.width <= 720 && am_private->video_rate == 1602)
+  {
+    CLog::Log(LOGDEBUG, "%s::%s video_rate exception", CLASSNAME, __func__);
+    am_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 24000;
+  }
+
+  // check for SD h264 content incorrectly reported as some form of 30 fsp
+  // mp4/avi containers :(
+  if (hints.codec == AV_CODEC_ID_H264 && hints.width <= 720)
+  {
+    if (am_private->video_rate >= 3200 && am_private->video_rate <= 3210)
+    {
+      CLog::Log(LOGDEBUG, "%s::%s video_rate exception", CLASSNAME, __func__);
+      am_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 24000;
+    }
+  }
+
+  // handle orientation
+  am_private->video_rotation_degree = 0;
+  if (hints.orientation == 90)
+    am_private->video_rotation_degree = 1;
+  else if (hints.orientation == 180)
+    am_private->video_rotation_degree = 2;
+  else if (hints.orientation == 270)
+    am_private->video_rotation_degree = 3;
+
+  // handle extradata
+  am_private->video_format      = codecid_to_vformat(hints.codec);
+  if (am_private->video_format == VFORMAT_H264) {
+    if (hints.width > 1920 || hints.height > 1088) {
+      am_private->video_format = VFORMAT_H264_4K2K;
+    }
+  }
+
+  am_private->extrasize       = hints.extrasize;
+  am_private->extradata       = (uint8_t*)malloc(hints.extrasize);
+  memcpy(am_private->extradata, hints.extradata, hints.extrasize);
+
+  if (am_private->stream_type == AM_STREAM_ES && am_private->video_codec_tag != 0)
+    am_private->video_codec_type = codec_tag_to_vdec_type(am_private->video_codec_tag);
+  if (am_private->video_codec_type == VIDEO_DEC_FORMAT_UNKNOW)
+    am_private->video_codec_type = codec_tag_to_vdec_type(am_private->video_codec_id);
+
+  am_private->flv_flag = 0;
+
+  CLog::Log(LOGDEBUG, "%s::%s hints.width(%d), hints.height(%d), hints.codec(%d), hints.codec_tag(%d), hints.pid(%d)",
+    CLASSNAME, __func__, hints.width, hints.height, hints.codec, hints.codec_tag, hints.pid);
+  CLog::Log(LOGDEBUG, "%s::%s hints.fpsrate(%d), hints.fpsscale(%d), hints.rfpsrate(%d), hints.rfpsscale(%d), video_rate(%d)",
+    CLASSNAME, __func__, hints.fpsrate, hints.fpsscale, hints.rfpsrate, hints.rfpsscale, am_private->video_rate);
+  CLog::Log(LOGDEBUG, "%s::%s hints.orientation(%d), hints.forced_aspect(%d), hints.extrasize(%d)",
+    CLASSNAME, __func__, hints.orientation, hints.forced_aspect, hints.extrasize);
+
+  // default video codec params
+  am_private->gcodec.noblock     = 0;
+  am_private->gcodec.video_pid   = am_private->video_pid;
+  am_private->gcodec.video_type  = am_private->video_format;
+  am_private->gcodec.stream_type = STREAM_TYPE_ES_VIDEO;
+  am_private->gcodec.format      = am_private->video_codec_type;
+  am_private->gcodec.width       = am_private->video_width;
+  am_private->gcodec.height      = am_private->video_height;
+  am_private->gcodec.rate        = am_private->video_rate;
+  am_private->gcodec.ratio       = am_private->video_ratio;
+  am_private->gcodec.ratio64     = am_private->video_ratio64;
+  am_private->gcodec.param       = NULL;
+
+  switch(am_private->video_format)
+  {
+    case VFORMAT_MPEG4:
+      am_private->gcodec.param = (void*)EXTERNAL_PTS;
+      break;
+    case VFORMAT_H264:
+    case VFORMAT_H264MVC:
+      am_private->gcodec.format = VIDEO_DEC_FORMAT_H264;
+      am_private->gcodec.param  = (void*)EXTERNAL_PTS;
+      // h264 in an avi file
+      if (m_hints.ptsinvalid)
+        am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
+      break;
+    case VFORMAT_H264_4K2K:
+      am_private->gcodec.format = VIDEO_DEC_FORMAT_H264_4K2K;
+      am_private->gcodec.param  = (void*)EXTERNAL_PTS;
+      // h264 in an avi file
+      if (m_hints.ptsinvalid)
+        am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
+      break;
+    case VFORMAT_HEVC:
+      am_private->gcodec.format = VIDEO_DEC_FORMAT_HEVC;
+      am_private->gcodec.param  = (void*)EXTERNAL_PTS;
+      if (m_hints.ptsinvalid)
+        am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
+      break;
+    default:
+      break;
+  }
+  am_private->gcodec.param = (void *)((unsigned int)am_private->gcodec.param | (am_private->video_rotation_degree << 16));
+
+  // translate from generic to firmware version dependent
+  codec_init_para(&am_private->gcodec, &am_private->vcodec);
+
+  int ret = codec_init(&am_private->vcodec);
+  if (ret != CODEC_ERROR_NONE)
+  {
+    CLog::Log(LOGERROR, "%s::%s codec init failed, ret=0x%x", CLASSNAME, __func__, -ret);
+    return false;
+  }
+
+  // make sure we are not stuck in pause (amcodec bug)
+  codec_resume(&am_private->vcodec);
+  codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+
+  codec_set_cntl_avthresh(&am_private->vcodec, AV_SYNC_THRESH);
+  codec_set_cntl_syncthresh(&am_private->vcodec, 0);
+  // disable tsync, we are playing video disconnected from audio.
+  SysfsUtils::SetInt("/sys/class/tsync/enable", 0);
+
+  am_private->am_pkt.codec = &am_private->vcodec;
+  pre_header_feeding(am_private, &am_private->am_pkt);
+
+  SetSpeed(m_speed);
+
+  SetViewport(hints.width, hints.height);
+  ShowMainVideo(true);
+
+  return true;
+}
+
+void CLinuxC1Codec::ShowMainVideo(const bool show)
+{
+  SysfsUtils::SetInt("/sys/class/video/disable_video", show ? 0 : 1);
+}
+
+void CLinuxC1Codec::SetSpeed(int speed)
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  m_speed = speed;
+
+  switch(speed)
+  {
+    case DVD_PLAYSPEED_PAUSE:
+      codec_pause(&am_private->vcodec);
+      codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+      break;
+    case DVD_PLAYSPEED_NORMAL:
+      codec_resume(&am_private->vcodec);
+      codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+      break;
+    default:
+      codec_resume(&am_private->vcodec);
+      if ((am_private->video_format == VFORMAT_H264) || (am_private->video_format == VFORMAT_H264_4K2K))
+        codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_FFFB);
+      else
+        codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_I);
+      break;
+  }
+}
+
+bool CLinuxC1Codec::GetPicture(DVDVideoPicture *pDvdVideoPicture)
+{
+  debug_log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  pDvdVideoPicture->iDuration = (double)(am_private->video_rate * DVD_TIME_BASE) / UNIT_FREQ;
+
+  pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  if (m_speed == DVD_PLAYSPEED_NORMAL)
+  {
+    pDvdVideoPicture->pts = GetPlayerPtsSeconds() * (double)DVD_TIME_BASE;
+    // video pts cannot be late or dvdplayer goes nuts,
+    // so run it one frame ahead
+    pDvdVideoPicture->pts += 1 * pDvdVideoPicture->iDuration;
+  }
+  else
+  {
+    // We are FF/RW; Do not use the Player clock or it just doesn't work
+    if (m_cur_pts == 0)
+      pDvdVideoPicture->pts = (double)m_1st_pts / PTS_FREQ * DVD_TIME_BASE;
+    else
+      pDvdVideoPicture->pts = (double)m_cur_pts / PTS_FREQ * DVD_TIME_BASE;
+  }
+
+  return true;
+}
+
+void CLinuxC1Codec::CloseDecoder() {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  // never leave vcodec ff/rw or paused.
+  if (m_speed != DVD_PLAYSPEED_NORMAL)
+  {
+    codec_resume(&am_private->vcodec);
+    codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+  }
+  codec_close(&am_private->vcodec);
+
+  am_packet_release(&am_private->am_pkt);
+  free(am_private->extradata);
+  am_private->extradata = NULL;
+  SysfsUtils::SetInt("/sys/class/tsync/enable", 1);
+
+  SetViewport(0, 0);
+  ShowMainVideo(false);
+  usleep(500 * 1000);
+}
+
+double CLinuxC1Codec::GetPlayerPtsSeconds()
+{
+  double clock_pts = 0.0;
+#ifndef THIS_IS_NOT_XBMC
+  CDVDClock *playerclock = CDVDClock::GetMasterClock();
+  if (playerclock)
+    clock_pts = playerclock->GetClock() / DVD_TIME_BASE;
+#endif
+  return clock_pts;
+}
+
+int CLinuxC1Codec::Decode(uint8_t *pData, size_t iSize, double dts, double pts) {
+  debug_log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  if (pData)
+  {
+    am_private->am_pkt.data = pData;
+    am_private->am_pkt.data_size = iSize;
+
+    am_private->am_pkt.newflag    = 1;
+    am_private->am_pkt.isvalid    = 1;
+    am_private->am_pkt.avduration = 0;
+
+    // handle pts, including 31bit wrap, aml can only handle 31
+    // bit pts as it uses an int in kernel.
+    if (m_hints.ptsinvalid || pts == DVD_NOPTS_VALUE)
+      am_private->am_pkt.avpts = AV_NOPTS_VALUE;
+    else
+    {
+      am_private->am_pkt.avpts = 0.5 + (pts * PTS_FREQ) / DVD_TIME_BASE;\
+      if (!m_start_pts && am_private->am_pkt.avpts >= 0x7fffffff)
+        m_start_pts = am_private->am_pkt.avpts & ~0x0000ffff;
+    }
+    if (am_private->am_pkt.avpts != (int64_t)AV_NOPTS_VALUE)
+      am_private->am_pkt.avpts -= m_start_pts;
+
+
+    // handle dts, including 31bit wrap, aml can only handle 31
+    // bit dts as it uses an int in kernel.
+    if (dts == DVD_NOPTS_VALUE)
+      am_private->am_pkt.avdts = AV_NOPTS_VALUE;
+    else
+    {
+      am_private->am_pkt.avdts = 0.5 + (dts * PTS_FREQ) / DVD_TIME_BASE;
+      if (!m_start_dts && am_private->am_pkt.avdts >= 0x7fffffff)
+        m_start_dts = am_private->am_pkt.avdts & ~0x0000ffff;
+    }
+    if (am_private->am_pkt.avdts != (int64_t)AV_NOPTS_VALUE)
+      am_private->am_pkt.avdts -= m_start_dts;
+
+    debug_log(LOGDEBUG, "%s::%s: iSize(%d), dts(%f), pts(%f), avdts(%llx), avpts(%llx)",
+      CLASSNAME, __func__, iSize, dts, pts, am_private->am_pkt.avdts, am_private->am_pkt.avpts);
+
+    while (am_private->am_pkt.isvalid)
+    {
+      // abort on any errors.
+      if (write_av_packet(am_private, &am_private->am_pkt) != PLAYER_SUCCESS)
+        break;
+
+      if (am_private->am_pkt.isvalid)
+        CLog::Log(LOGDEBUG, "%s::%s: write_av_packet looping", CLASSNAME, __func__);
+    }
+
+    // if we seek, then GetTimeSize is wrong as
+    // reports lastpts - cur_pts and hw decoder has
+    // not started outputing new pts values yet.
+    // so we grab the 1st pts sent into driver and
+    // use that to calc GetTimeSize.
+    if (m_1st_pts == 0)
+      m_1st_pts = am_private->am_pkt.lastpts;
+  }
+
+  int64_t pts_video = 0;
+  int rtn = VC_BUFFER;
+  pts_video = get_pts_video();
+  if (pts_video != m_cur_pts) {
+    m_cur_pts = pts_video;
+    m_cur_pictcnt++;
+    m_old_pictcnt++;
+    rtn |= VC_PICTURE;
+  }
+
+  debug_log(LOGDEBUG, "%s::%s rtn(%d), m_cur_pictcnt(%lld), m_cur_pts(%f), lastpts(%f)",
+    CLASSNAME, __func__, rtn, m_cur_pictcnt, (float)m_cur_pts/PTS_FREQ, (float)am_private->am_pkt.lastpts/PTS_FREQ);
+
+  return rtn;
+}
+
+void CLinuxC1Codec::Reset() {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  int blackout_policy;
+  SysfsUtils::GetInt("/sys/class/video/blackout_policy", blackout_policy);
+  SysfsUtils::SetInt("/sys/class/video/blackout_policy", 0);
+
+  if (m_speed != DVD_PLAYSPEED_NORMAL)
+  {
+    codec_resume(&am_private->vcodec);
+    codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+  }
+  codec_reset(&am_private->vcodec);
+
+  am_packet_release(&am_private->am_pkt);
+  memzero(am_private->am_pkt);
+  am_private->am_pkt.codec = &am_private->vcodec;
+  pre_header_feeding(am_private, &am_private->am_pkt);
+
+  SysfsUtils::SetInt("/sys/class/video/blackout_policy", blackout_policy);
+
+  m_1st_pts = 0;
+  m_cur_pts = 0;
+  m_cur_pictcnt = 0;
+  m_old_pictcnt = 0;
+  SetSpeed(m_speed);
+}
+
+void CLinuxC1Codec::SetViewport(int width, int height) {
+
+  if (m_hints.aspect > 0.0 && (((int)lrint(height * m_hints.aspect)) & -3) > width)
+    width = ((int)lrint(height * m_hints.aspect)) & -3;
+
+  char setting[256] = {};
+  double scale;
+  int displayWidth = CDisplaySettings::Get().GetCurrentResolutionInfo().iWidth;
+  int displayHeight = CDisplaySettings::Get().GetCurrentResolutionInfo().iHeight;
+  int cutWidth;
+  int cutHeight;
+
+  if (width > 0 && height > 0) {
+    scale = fmin((double)displayWidth / (double)width, (double)displayHeight / (double)height);
+    cutWidth = (displayWidth - (int)((double)width * scale)) / 2;
+    cutHeight = (displayHeight - (int)((double)height * scale)) / 2;
+    sprintf(setting, "%d %d %d %d", 0 + cutWidth, 0 + cutHeight, displayWidth - cutWidth, displayHeight - cutHeight);
+  } else {
+    sprintf(setting, "%d %d %d %d", 0, 0, 0, 0);
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s Setting viewport to %s", CLASSNAME, __func__, setting);
+  SysfsUtils::SetString("/sys/class/video/axis", setting);
+  SysfsUtils::SetInt("/sys/class/video/screen_mode", 1);
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.h
new file mode 100644
index 0000000..f1a194c
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.h
@@ -0,0 +1,167 @@
+#pragma once
+
+#include <queue>
+#include <string>
+#include <math.h>
+#include <poll.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+  #include <amcodec/codec.h>
+  #include <amcodec/codec_type.h>
+#ifdef __cplusplus
+}
+#endif
+#include <adec-external-ctrl.h>
+
+#ifdef _DEBUG
+  #define debug_log(...) CLog::Log(__VA_ARGS__)
+#else
+  #define debug_log(...)
+#endif
+
+#ifndef THIS_IS_NOT_XBMC
+  #include "DVDVideoCodec.h"
+  #include "DVDClock.h"
+  #include "DVDStreamInfo.h"
+  #include "settings/DisplaySettings.h"
+  #include "utils/BitstreamConverter.h"
+  #include "utils/SysfsUtils.h"
+#else
+  #include "xbmcstubs.h"
+#endif
+
+#define memzero(x) memset(&(x), 0, sizeof (x))
+
+#define PTS_FREQ        90000
+#define UNIT_FREQ       96000
+#define AV_SYNC_THRESH  PTS_FREQ*30
+
+#define TRICKMODE_NONE  0x00
+#define TRICKMODE_I     0x01
+#define TRICKMODE_FFFB  0x02
+
+#define EXTERNAL_PTS    (1)
+#define SYNC_OUTSIDE    (2)
+
+#define HDR_BUF_SIZE 1024
+
+#define P_PRE                     (0x02000000)
+#define PLAYER_SUCCESS            (0)
+#define PLAYER_FAILED             (-(P_PRE|0x01))
+#define PLAYER_NOMEM              (-(P_PRE|0x02))
+#define PLAYER_EMPTY_P            (-(P_PRE|0x03))
+#define PLAYER_WR_FAILED          (-(P_PRE|0x21))
+#define PLAYER_WR_EMPTYP          (-(P_PRE|0x22))
+#define PLAYER_WR_FINISH          (P_PRE|0x1)
+#define PLAYER_PTS_ERROR          (-(P_PRE|0x31))
+#define PLAYER_UNSUPPORT          (-(P_PRE|0x35))
+#define PLAYER_CHECK_CODEC_ERROR  (-(P_PRE|0x39))
+
+#define RW_WAIT_TIME    (20 * 1000) // 20ms
+
+typedef struct hdr_buf {
+    char *data;
+    int size;
+} hdr_buf_t;
+
+typedef struct am_packet {
+    AVPacket      avpkt;
+    int64_t       avpts;
+    int64_t       avdts;
+    int           avduration;
+    int           isvalid;
+    int           newflag;
+    int64_t       lastpts;
+    unsigned char *data;
+    unsigned char *buf;
+    int           data_size;
+    int           buf_size;
+    hdr_buf_t     *hdr;
+    codec_para_t  *codec;
+} am_packet_t;
+
+typedef enum {
+    AM_STREAM_UNKNOWN = 0,
+    AM_STREAM_TS,
+    AM_STREAM_PS,
+    AM_STREAM_ES,
+    AM_STREAM_RM,
+    AM_STREAM_AUDIO,
+    AM_STREAM_VIDEO,
+} pstream_type;
+
+typedef struct {
+  bool          noblock;
+  int           video_pid;
+  int           video_type;
+  stream_type_t stream_type;
+  unsigned int  format;
+  unsigned int  width;
+  unsigned int  height;
+  unsigned int  rate;
+  unsigned int  extra;
+  unsigned int  status;
+  unsigned int  ratio;
+  unsigned long long ratio64;
+  void *param;
+} aml_generic_param;
+
+typedef struct am_private_t
+{
+  am_packet_t       am_pkt;
+  aml_generic_param gcodec;
+  codec_para_t      vcodec;
+
+  pstream_type      stream_type;
+  int               check_first_pts;
+
+  vformat_t         video_format;
+  int               video_pid;
+  unsigned int      video_codec_id;
+  unsigned int      video_codec_tag;
+  vdec_type_t       video_codec_type;
+  unsigned int      video_width;
+  unsigned int      video_height;
+  unsigned int      video_ratio;
+  unsigned int      video_ratio64;
+  unsigned int      video_rate;
+  unsigned int      video_rotation_degree;
+  int               flv_flag;
+  int               h263_decodable;
+  int               extrasize;
+  uint8_t           *extradata;
+
+  int               dumpfile;
+  bool              dumpdemux;
+} am_private_t;
+
+class CLinuxC1Codec
+{
+public:
+  CLinuxC1Codec();
+  ~CLinuxC1Codec();
+
+  bool             OpenDecoder(CDVDStreamInfo &hints);
+  void             CloseDecoder();
+  int              Decode(uint8_t *pData, size_t size, double dts, double pts);
+  bool             GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  void             Reset();
+  void             SetSpeed(int speed);
+
+private:
+  volatile int     m_speed;
+  CDVDStreamInfo   m_hints;
+  am_private_t    *am_private;
+  volatile int64_t m_1st_pts;
+  volatile int64_t m_cur_pts;
+  volatile int64_t m_cur_pictcnt;
+  volatile int64_t m_old_pictcnt;
+  int64_t          m_start_dts;
+  int64_t          m_start_pts;
+
+  void             SetViewport(int width, int height);
+  double           GetPlayerPtsSeconds();
+  void             ShowMainVideo(const bool show);
+};
diff --git a/xbmc/linux/LinuxV4l2Sink.cpp b/xbmc/linux/LinuxV4l2Sink.cpp
new file mode 100644
index 0000000..bd5201e
--- /dev/null
+++ b/xbmc/linux/LinuxV4l2Sink.cpp
@@ -0,0 +1,311 @@
+#include "system.h"
+
+#ifndef THIS_IS_NOT_XBMC
+  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
+    #include "config.h"
+  #endif
+
+  #include "utils/log.h"
+#endif
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <linux/media.h>
+
+#include "LinuxV4l2Sink.h"
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CLinuxV4l2Sink"
+
+CLinuxV4l2Sink::CLinuxV4l2Sink(V4l2Device *device, enum v4l2_buf_type type) {
+  CLog::Log(LOGDEBUG, "%s::%s - Creating Sink, Device %s, Type %d", CLASSNAME, __func__, device->name, type);
+  m_Device = device;
+  m_Type = type;
+  m_NumBuffers = 0;
+  m_NumPlanes = 0;
+  m_Addresses = NULL;
+  m_Buffers = NULL;
+  m_Planes = NULL;
+}
+
+CLinuxV4l2Sink::~CLinuxV4l2Sink() {
+  CLog::Log(LOGDEBUG, "%s::%s - Destroying Sink, Device %s, Type %d", CLASSNAME, __func__, m_Device->name, m_Type);
+
+  StreamOn(VIDIOC_STREAMOFF);
+
+  if (m_Memory == V4L2_MEMORY_MMAP)
+    for (int i = 0; i < m_NumBuffers*m_NumPlanes; i++)
+      if(m_Addresses[i] != (unsigned long)MAP_FAILED)
+        if (munmap((void *)m_Addresses[i], m_Planes[i].length) == 0)
+          CLog::Log(LOGDEBUG, "%s::%s - Device %s, Munmapped Plane %d size %u at 0x%lx", CLASSNAME, __func__, m_Device->name, i, m_Planes[i].length, m_Addresses[i]);
+  if (m_Planes)
+    delete[] m_Planes;
+  if (m_Buffers)
+    delete[] m_Buffers;
+  if (m_Addresses)
+    delete[] m_Addresses;
+}
+
+// Init for MMAP buffers
+bool CLinuxV4l2Sink::Init(int buffersCount = 0) {
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Init MMAP %d buffers", CLASSNAME, __func__, m_Device->name, m_Type, buffersCount);
+  m_Memory = V4L2_MEMORY_MMAP;
+
+  struct v4l2_format format;
+  if (!GetFormat(&format))
+    return false;
+
+  if (buffersCount == 0 && m_Type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+    struct v4l2_control ctrl;
+    ctrl.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE;
+    if (ioctl(m_Device->device, VIDIOC_G_CTRL, &ctrl)) {
+      CLog::Log(LOGERROR, "%s::%s - Device %s, Type %d, Error getting number of buffers for capture (V4L2_CID_MIN_BUFFERS_FOR_CAPTURE VIDIOC_G_CTRL)", CLASSNAME, __func__, m_Device->name, m_Type);
+      return false;
+    }
+    buffersCount = (int)(ctrl.value * 1.5); //Most of the time we need 50% more extra capture buffers than device reported would be enough
+  }
+
+  m_NumBuffers = RequestBuffers(buffersCount);
+  if (m_NumBuffers < 1)
+    return false;
+  m_Buffers = new v4l2_buffer[m_NumBuffers];
+  m_Planes = new v4l2_plane[m_NumPlanes * m_NumBuffers];
+  m_Addresses = new unsigned long[m_NumPlanes * m_NumBuffers];
+  if (!QueryBuffers())
+    return false;
+  if (!MmapBuffers())
+    return false;
+  return true;
+}
+// Init for USERPTR buffers
+bool CLinuxV4l2Sink::Init(CLinuxV4l2Sink *sink) {
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Init UserPTR", CLASSNAME, __func__, m_Device->name, m_Type);
+  m_Memory = V4L2_MEMORY_USERPTR;
+
+  struct v4l2_format format;
+  if (!GetFormat(&format))
+    return false;
+
+  m_NumBuffers = sink->m_NumBuffers;
+  m_NumBuffers = RequestBuffers(m_NumBuffers);
+  if (m_NumBuffers < 1)
+    return false;
+  m_Buffers = new v4l2_buffer[m_NumBuffers];
+  m_Planes = new v4l2_plane[m_NumPlanes * m_NumBuffers];
+  m_Addresses = new unsigned long[m_NumPlanes * m_NumBuffers];
+  if (!QueryBuffers())
+    return false;
+  for (int i = 0; i < m_NumPlanes * m_NumBuffers; i++) {
+    m_Addresses[i] = sink->m_Addresses[i];
+    m_Planes[i].m.userptr = m_Addresses[i];
+  }
+  return true;
+}
+
+void CLinuxV4l2Sink::SoftRestart() {
+  StreamOn(VIDIOC_STREAMOFF);
+
+  while (!iFreeBuffers.empty())
+    iFreeBuffers.pop();
+  for (int i = 0; i < m_NumBuffers; i++)
+    iFreeBuffers.push(m_Buffers[i].index);
+
+  if (m_Type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+    QueueAll();
+
+  StreamOn(VIDIOC_STREAMON);
+}
+
+bool CLinuxV4l2Sink::GetFormat(v4l2_format *format) {
+  memset(format, 0, sizeof(struct v4l2_format));
+  format->type = m_Type;
+  if (ioctl(m_Device->device, VIDIOC_G_FMT, format)) {
+    CLog::Log(LOGERROR, "%s::%s - Error getting sink format. Device %s, Type %d. (VIDIOC_G_FMT)", CLASSNAME, __func__, m_Device->name, m_Type);
+    return false;
+  }
+  m_NumPlanes = format->fmt.pix_mp.num_planes;
+  CLog::Log(LOGDEBUG, "%s::%s - G_FMT Device %s, Type %d format 0x%x (%dx%d), planes=%d, plane[0]=%d plane[1]=%d, plane[2]=%d", CLASSNAME, __func__, m_Device->name, format->type, format->fmt.pix_mp.pixelformat, format->fmt.pix_mp.width, format->fmt.pix_mp.height, format->fmt.pix_mp.num_planes, format->fmt.pix_mp.plane_fmt[0].sizeimage, format->fmt.pix_mp.plane_fmt[1].sizeimage, format->fmt.pix_mp.plane_fmt[2].sizeimage);
+  return true;
+}
+
+bool CLinuxV4l2Sink::SetFormat(v4l2_format *format) {
+  format->type = m_Type;
+  CLog::Log(LOGDEBUG, "%s::%s - S_FMT Device %s, Type %d format 0x%x (%dx%d), planes=%d, plane[0]=%d plane[1]=%d, plane[2]=%d", CLASSNAME, __func__, m_Device->name, format->type, format->fmt.pix_mp.pixelformat, format->fmt.pix_mp.width, format->fmt.pix_mp.height, format->fmt.pix_mp.num_planes, format->fmt.pix_mp.plane_fmt[0].sizeimage, format->fmt.pix_mp.plane_fmt[1].sizeimage, format->fmt.pix_mp.plane_fmt[2].sizeimage);
+  if (ioctl(m_Device->device, VIDIOC_S_FMT, format)) {
+    CLog::Log(LOGERROR, "%s::%s - Error setting sink format. Device %s, Type %d. (VIDIOC_G_FMT)", CLASSNAME, __func__, m_Device->name, m_Type);
+    return false;
+  }
+  return true;
+}
+
+bool CLinuxV4l2Sink::GetCrop(v4l2_crop *crop) {
+  memset(crop, 0, sizeof(struct v4l2_crop));
+  crop->type = m_Type;
+  if (ioctl(m_Device->device, VIDIOC_G_CROP, crop)) {
+    CLog::Log(LOGERROR, "%s::%s - Error getting sink crop. Device %s, Type %d. (VIDIOC_G_CROP)", CLASSNAME, __func__, m_Device->name, m_Type);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - G_CROP Device %s, Type %d, crop (%dx%d)", CLASSNAME, __func__, m_Device->name, crop->type, crop->c.width, crop->c.height);
+  return true;
+}
+
+bool CLinuxV4l2Sink::SetCrop(v4l2_crop *crop) {
+  crop->type = m_Type;
+  CLog::Log(LOGDEBUG, "%s::%s - S_CROP Device %s, Type %d, crop (%dx%d)", CLASSNAME, __func__, m_Device->name, crop->type, crop->c.width, crop->c.height);
+  if (ioctl(m_Device->device, VIDIOC_S_CROP, crop)) {
+    CLog::Log(LOGERROR, "%s::%s - Error setting sink crop. Device %s, Type %d. (VIDIOC_G_CROP)", CLASSNAME, __func__, m_Device->name, m_Type);
+    return false;
+  }
+  return true;
+}
+
+int CLinuxV4l2Sink::RequestBuffers(int buffersCount) {
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d, RequestBuffers %d", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory, buffersCount);
+  struct v4l2_requestbuffers reqbuf;
+  memset(&reqbuf, 0, sizeof(struct v4l2_requestbuffers));
+  reqbuf.type     = m_Type;
+  reqbuf.memory   = m_Memory;
+  reqbuf.count    = buffersCount;
+
+  if (ioctl(m_Device->device, VIDIOC_REQBUFS, &reqbuf)) {
+    CLog::Log(LOGERROR, "%s::%s - Error requesting buffers. Device %s, Type %d, Memory %d. (VIDIOC_REQBUFS)", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory);
+    return V4L2_ERROR;
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d, Buffers allowed %d", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory, reqbuf.count);
+  return reqbuf.count;
+}
+
+bool CLinuxV4l2Sink::QueryBuffers() {
+  memset(m_Buffers, 0, m_NumBuffers * sizeof(struct v4l2_buffer));
+  memset(m_Planes, 0, m_NumBuffers * m_NumPlanes * sizeof(struct v4l2_plane));
+
+  for(int i = 0; i < m_NumBuffers; i++) {
+    m_Buffers[i].type      = m_Type;
+    m_Buffers[i].memory    = m_Memory;
+    m_Buffers[i].index     = i;
+    m_Buffers[i].m.planes  = &m_Planes[i*m_NumPlanes];
+    m_Buffers[i].length    = m_NumPlanes;
+
+    if (ioctl(m_Device->device, VIDIOC_QUERYBUF, &m_Buffers[i])) {
+      CLog::Log(LOGERROR, "%s::%s - Error querying buffers. Device %s, Type %d, Memory %d. (VIDIOC_QUERYBUF)", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory);
+      return false;
+    }
+
+    iFreeBuffers.push(m_Buffers[i].index);
+  }
+  return true;
+}
+
+bool CLinuxV4l2Sink::MmapBuffers() {
+  for(int i = 0; i < m_NumBuffers * m_NumPlanes; i++) {
+    if(m_Planes[i].length) {
+      m_Addresses[i] = (unsigned long)mmap(NULL, m_Planes[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, m_Device->device, m_Planes[i].m.mem_offset);
+      if (m_Addresses[i] == (unsigned long)MAP_FAILED)
+        return false;
+      CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, MMapped Plane %d at 0x%x to address 0x%lx", CLASSNAME, __func__, m_Device->name, m_Type, i, m_Planes[i].m.mem_offset, m_Addresses[i]);
+    }
+  }
+  return true;
+}
+
+bool CLinuxV4l2Sink::StreamOn(int state) {
+  if(ioctl(m_Device->device, state, &m_Type)) {
+    CLog::Log(LOGERROR, "%s::%s - Error setting device state to %d, Device %s, Type %d.", CLASSNAME, __func__, state, m_Device->name, m_Type);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, %d", CLASSNAME, __func__, m_Device->name, m_Type, state);
+  return true;
+}
+
+bool CLinuxV4l2Sink::QueueBuffer(v4l2_buffer *buffer) {
+  debug_log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d <- %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index);
+  if (ioctl(m_Device->device, VIDIOC_QBUF, buffer)) {
+    CLog::Log(LOGERROR, "%s::%s - Error queueing buffer. Device %s, Type %d, Memory %d. Buffer %d, errno %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index, errno);
+    return false;
+  }
+  return true;
+}
+bool CLinuxV4l2Sink::DequeueBuffer(v4l2_buffer *buffer) {
+  if (ioctl(m_Device->device, VIDIOC_DQBUF, buffer)) {
+    if (errno != EAGAIN) CLog::Log(LOGERROR, "%s::%s - Error dequeueing buffer. Device %s, Type %d, Memory %d. Buffer %d, errno %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index, errno);
+    return false;
+  }
+  debug_log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d -> %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index);
+  return true;
+}
+
+bool CLinuxV4l2Sink::DequeueBuffer(V4l2SinkBuffer *buffer) {
+  struct v4l2_buffer buf;
+  struct v4l2_plane  planes[m_NumPlanes];
+  memset(&planes, 0, sizeof(struct v4l2_plane) * m_NumPlanes);
+  memset(&buf, 0, sizeof(struct v4l2_buffer));
+  buf.type     = m_Type;
+  buf.memory   = m_Memory;
+  buf.m.planes = planes;
+  buf.length   = m_NumPlanes;
+  if (!DequeueBuffer(&buf))
+    return false;
+
+  buffer->iIndex = buf.index;
+  buffer->timeStamp = buf.timestamp;
+  for (int i = 0; i < m_NumPlanes; i++)
+    buffer->cPlane[i] = (void *)m_Addresses[buffer->iIndex * m_NumPlanes + i];
+  return true;
+}
+
+bool CLinuxV4l2Sink::GetBuffer(V4l2SinkBuffer *buffer) {
+  if (iFreeBuffers.empty()) {
+    if (!DequeueBuffer(buffer))
+      return false;
+  } else {
+    buffer->iIndex = iFreeBuffers.front();
+    buffer->timeStamp = m_Buffers[buffer->iIndex].timestamp;
+    iFreeBuffers.pop();
+    for (int i = 0; i < m_NumPlanes; i++)
+      buffer->cPlane[i] = (void *)m_Addresses[buffer->iIndex * m_NumPlanes + i];
+  }
+  return true;
+}
+
+bool CLinuxV4l2Sink::PushBuffer(V4l2SinkBuffer *buffer) {
+  if (m_Memory == V4L2_MEMORY_USERPTR)
+    for (int i = 0; i < m_NumPlanes; i++)
+      m_Buffers[buffer->iIndex].m.planes[i].m.userptr = (long unsigned int)buffer->cPlane[i];
+
+  if (m_Type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+    m_Buffers[buffer->iIndex].timestamp = buffer->timeStamp;
+    m_Buffers[buffer->iIndex].flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+    for (int i = 0; i < m_NumPlanes; i++)
+      m_Buffers[buffer->iIndex].m.planes[i].bytesused = buffer->iBytesUsed[i];
+  }
+
+  if (!QueueBuffer(&m_Buffers[buffer->iIndex]))
+    return false;
+  return true;
+}
+
+int CLinuxV4l2Sink::Poll(int timeout) {
+  struct pollfd p;
+  p.fd = m_Device->device;
+  p.events = POLLERR;
+  (m_Type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) ? p.events |= POLLOUT : p.events |= POLLIN;
+
+  return poll(&p, 1, timeout);
+}
+
+bool CLinuxV4l2Sink::QueueAll() {
+  while (!iFreeBuffers.empty()) {
+    if (!QueueBuffer(&m_Buffers[iFreeBuffers.front()]))
+      return false;
+    iFreeBuffers.pop();
+  }
+  return true;
+}
diff --git a/xbmc/linux/LinuxV4l2Sink.h b/xbmc/linux/LinuxV4l2Sink.h
new file mode 100644
index 0000000..d04d52d
--- /dev/null
+++ b/xbmc/linux/LinuxV4l2Sink.h
@@ -0,0 +1,71 @@
+#pragma once
+
+#include <queue>
+#include <string>
+#include <poll.h>
+#include <linux/videodev2.h>
+
+#ifndef V4L2_BUF_FLAG_TIMESTAMP_COPY
+  #define V4L2_BUF_FLAG_TIMESTAMP_COPY 0x4000
+#endif
+
+#define V4L2_ERROR -1
+#define V4L2_BUSY  1
+#define V4L2_READY 2
+#define V4L2_OK    3
+
+#ifdef _DEBUG
+  #define debug_log(...) CLog::Log(__VA_ARGS__)
+#else
+  #define debug_log(...)
+#endif
+
+typedef struct V4l2Device
+{
+  int     device;
+  char    name[32];
+} V4l2Device;
+
+typedef struct V4l2SinkBuffer
+{
+  int     iIndex;
+  int     iBytesUsed[4];
+  void    *cPlane[4];
+  struct  timeval timeStamp;
+} V4l2SinkBuffer;
+
+class CLinuxV4l2Sink
+{
+public:
+  CLinuxV4l2Sink(V4l2Device *device, enum v4l2_buf_type type);
+  ~CLinuxV4l2Sink();
+
+  bool Init(int buffersCount);
+  bool Init(CLinuxV4l2Sink *sink);
+  void SoftRestart();
+  bool GetFormat(v4l2_format *format);
+  bool SetFormat(v4l2_format *format);
+  bool GetCrop(v4l2_crop *crop);
+  bool SetCrop(v4l2_crop *crop);
+  bool GetBuffer(V4l2SinkBuffer* buffer);
+  bool DequeueBuffer(V4l2SinkBuffer* buffer);
+  bool PushBuffer(V4l2SinkBuffer* buffer);
+  bool StreamOn(int state);
+  bool QueueAll();
+  int Poll(int timeout);
+private:
+  V4l2Device *m_Device;
+  int m_NumPlanes;
+  int m_NumBuffers;
+  std::queue<int> iFreeBuffers;
+  enum v4l2_memory m_Memory;
+  enum v4l2_buf_type m_Type;
+  v4l2_buffer *m_Buffers;
+  v4l2_plane *m_Planes;
+  unsigned long *m_Addresses;
+  int RequestBuffers(int buffersCount);
+  bool QueryBuffers();
+  bool MmapBuffers();
+  bool QueueBuffer(v4l2_buffer *buffer);
+  bool DequeueBuffer(v4l2_buffer *buffer);
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp b/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp
new file mode 100644
index 0000000..41ab866
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp
@@ -0,0 +1,196 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <EGL/egl.h>
+#include "EGLNativeTypeFbdev.h"
+#include "utils/log.h"
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include "utils/StringUtils.h"
+#include "guilib/gui3d.h"
+#include <linux/media.h>
+
+#include <unistd.h>
+
+#include "utils/StringUtils.h"
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CEGLNativeTypeFbdev"
+
+CEGLNativeTypeFbdev::CEGLNativeTypeFbdev()
+{
+  m_iFBHandle = -1;
+  m_nativeWindow  = NULL;
+  m_nativeDisplay = NULL;
+}
+
+CEGLNativeTypeFbdev::~CEGLNativeTypeFbdev()
+{
+  if (m_nativeWindow)
+    free(m_nativeWindow);
+
+  if (vinfo)
+    free(vinfo);
+  if (finfo)
+    free(finfo);
+
+  if(m_iFBHandle >= 0)
+  {
+    close(m_iFBHandle);
+    m_iFBHandle = -1;
+  }
+}
+
+bool CEGLNativeTypeFbdev::CheckCompatibility()
+{
+  m_iFBHandle = open("/dev/fb0", O_RDWR, 0);
+  if(m_iFBHandle < 0)
+    return false;
+
+  vinfo = new fb_var_screeninfo();
+  if(ioctl(m_iFBHandle, FBIOGET_VSCREENINFO, vinfo) == -1)
+    return false;
+
+  CLog::Log(LOGNOTICE, "%s::%s FBDev device: %d, info.xres %d info.yres %d info.upper_margin %d info.lower_margin %d info.pixclock %d",
+    CLASSNAME, __func__, m_iFBHandle, vinfo->xres, vinfo->yres, vinfo->upper_margin, vinfo->lower_margin, vinfo->pixclock);
+
+  finfo = new fb_fix_screeninfo();
+  if(ioctl(m_iFBHandle, FBIOGET_FSCREENINFO, finfo) == -1)
+    return false;
+
+  return true;
+}
+
+void CEGLNativeTypeFbdev::Initialize()
+{
+  return;
+}
+void CEGLNativeTypeFbdev::Destroy()
+{
+  return;
+}
+
+bool CEGLNativeTypeFbdev::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::CreateNativeWindow()
+{
+  fbdev_window *nativeWindow = new fbdev_window;
+  if (!nativeWindow)
+    return false;
+
+  nativeWindow->width = vinfo->xres;
+  nativeWindow->height = vinfo->yres;
+  m_nativeWindow = nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::DestroyNativeWindow()
+{
+  free(m_nativeWindow);
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  res->iWidth = vinfo->xres;
+  res->iHeight = vinfo->yres;
+  res->fRefreshRate = 60;
+  res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  res->iScreen = 0;
+  res->bFullScreen = true;
+  res->iSubtitles = (int)(0.965 * res->iHeight);
+  res->fPixelRatio = 1.0f;
+  res->iScreenWidth = res->iWidth;
+  res->iScreenHeight = res->iHeight;
+  res->strMode = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate, res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  CLog::Log(LOGNOTICE, "Current resolution: %s", res->strMode.c_str());
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+
+  vinfo->activate = FB_ACTIVATE_NOW;
+
+  if (ioctl(m_iFBHandle, FBIOPUT_VSCREENINFO, vinfo) == -1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - FBIOPUT_VSCREENINFO error", CLASSNAME, __func__);
+    return false;
+  }
+  if (ioctl(m_iFBHandle, FBIOPAN_DISPLAY, vinfo) == -1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - FBIOPAN_DISPLAY error", CLASSNAME, __func__);
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE, "%s::%s width %d height %d refresh %f", CLASSNAME, __func__, res.iScreenWidth, res.iScreenHeight, res.fRefreshRate);
+
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  RESOLUTION_INFO res;
+  if (GetNativeResolution(&res) && res.iWidth > 1 && res.iHeight > 1)
+  {
+    resolutions.push_back(res);
+    return true;
+  }
+  return false;
+}
+
+bool CEGLNativeTypeFbdev::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+    GetNativeResolution(res);
+    return true;
+}
+
+bool CEGLNativeTypeFbdev::ShowWindow(bool show)
+{
+  return false;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeFbdev.h b/xbmc/windowing/egl/EGLNativeTypeFbdev.h
new file mode 100644
index 0000000..04e7023
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeFbdev.h
@@ -0,0 +1,68 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+#include <linux/fb.h>
+#include <list>
+
+#ifndef _FBDEV_WINDOW_H_
+// Define it right here, since some platforms doesn't has fbdev_window.h at all.
+// This will not make it fail on these platforms badly, since it will fail softly anyway on some other init steps.
+#define _FBDEV_WINDOW_H_
+typedef struct fbdev_window
+{
+  unsigned short width;
+  unsigned short height;
+} fbdev_window;
+#endif
+
+class CEGLNativeTypeFbdev : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeFbdev();
+  virtual ~CEGLNativeTypeFbdev();
+  virtual std::string GetNativeName() const { return "FBDev"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+protected:
+  int m_iFBHandle;
+  fb_var_screeninfo *vinfo;
+  fb_fix_screeninfo *finfo;
+};
diff --git a/xbmc/windowing/egl/EGLNativeTypeHybris.cpp b/xbmc/windowing/egl/EGLNativeTypeHybris.cpp
new file mode 100644
index 0000000..767946e
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeHybris.cpp
@@ -0,0 +1,279 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#if defined(TARGET_HYBRIS)
+#include <hwcomposerwindow/hwcomposer_window.h>
+#include <hardware/hardware.h>
+#include <hardware/hwcomposer.h>
+#endif
+
+#include "system.h"
+#include <EGL/egl.h>
+#include "EGLNativeTypeHybris.h"
+#include "utils/log.h"
+#include "guilib/gui3d.h"
+
+#include "utils/StringUtils.h"
+
+HWComposer::HWComposer(unsigned int width,
+                      unsigned int height,
+                      unsigned int format,
+                      hwc_composer_device_1_t *device,
+                      hwc_display_contents_1_t **mList,
+                      hwc_layer_1_t *layer)
+                      : HWComposerNativeWindow(width, height, format)
+{
+    fblayer = layer;
+    hwcdevice = device;
+    mlist = mList;
+}
+
+void HWComposer::present(HWComposerNativeWindowBuffer *buffer)
+{
+    int oldretire = mlist[0]->retireFenceFd;
+    mlist[0]->retireFenceFd = -1;
+    fblayer->handle = buffer->handle;
+    fblayer->acquireFenceFd = getFenceBufferFd(buffer);
+    fblayer->releaseFenceFd = -1;
+    int err = hwcdevice->prepare(hwcdevice, HWC_NUM_DISPLAY_TYPES, mlist);
+    assert(err == 0);
+
+    err = hwcdevice->set(hwcdevice, HWC_NUM_DISPLAY_TYPES, mlist);
+    assert(err == 0);
+    setFenceBufferFd(buffer, fblayer->releaseFenceFd);
+
+    if (oldretire != -1)
+    {
+        sync_wait(oldretire, -1);
+        close(oldretire);
+    }
+}
+
+CEGLNativeTypeHybris::CEGLNativeTypeHybris()
+#if defined(TARGET_HYBRIS)
+ : m_hwcModule(NULL), m_bufferList(NULL), m_hwcDevicePtr(NULL)
+{
+  m_nativeWindow = NULL;
+  m_hwNativeWindow = NULL;
+  m_swNativeWindow = NULL;
+}
+#else
+{
+}
+#endif
+
+CEGLNativeTypeHybris::~CEGLNativeTypeHybris()
+{
+}
+
+bool CEGLNativeTypeHybris::CheckCompatibility()
+{
+#if defined(TARGET_HYBRIS)
+  if(hw_get_module(HWC_HARDWARE_MODULE_ID, (const hw_module_t **) &m_hwcModule))
+  {
+    return false;
+  }
+
+  if(hwc_open_1(m_hwcModule, &m_hwcDevicePtr))
+  {
+    return false;
+  }
+
+  m_hwcDevicePtr->blank(m_hwcDevicePtr, 0, 0);
+  return true;
+#else
+  return false;
+#endif
+}
+
+void CEGLNativeTypeHybris::Initialize()
+{
+}
+
+void CEGLNativeTypeHybris::Destroy()
+{
+  return;
+}
+
+bool CEGLNativeTypeHybris::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeHybris::CreateNativeWindow()
+{
+#if defined(TARGET_HYBRIS)
+  RESOLUTION_INFO res;
+  if (!GetNativeResolution(&res))
+    return false;
+
+  size_t size = sizeof(hwc_display_contents_1_t) + 2 * sizeof(hwc_layer_1_t);
+  hwc_display_contents_1_t *list = (hwc_display_contents_1_t *) malloc(size);
+  m_bufferList = (hwc_display_contents_1_t **) malloc(HWC_NUM_DISPLAY_TYPES * sizeof(hwc_display_contents_1_t *));
+  const hwc_rect_t r = { 0, 0, res.iWidth, res.iHeight };
+
+  for (int counter = 0; counter < HWC_NUM_DISPLAY_TYPES; counter++)
+    m_bufferList[counter] = list;
+
+  hwc_layer_1_t *layer;
+
+  layer = &list->hwLayers[0];
+  memset(layer, 0, sizeof(hwc_layer_1_t));
+  layer->compositionType = HWC_FRAMEBUFFER;
+  layer->hints = 0;
+  layer->flags = 0;
+  layer->handle = 0;
+  layer->transform = 0;
+  layer->blending = HWC_BLENDING_NONE;
+  layer->sourceCrop = r;
+  layer->displayFrame = r;
+  layer->visibleRegionScreen.numRects = 1;
+  layer->visibleRegionScreen.rects = &layer->displayFrame;
+  layer->acquireFenceFd = -1;
+  layer->releaseFenceFd = -1;
+
+  layer = &list->hwLayers[1];
+  memset(layer, 0, sizeof(hwc_layer_1_t));
+  layer->compositionType = HWC_FRAMEBUFFER_TARGET;
+  layer->hints = 0;
+  layer->flags = 0;
+  layer->handle = 0;
+  layer->transform = 0;
+  layer->blending = HWC_BLENDING_NONE;
+  layer->sourceCrop = r;
+  layer->displayFrame = r;
+  layer->visibleRegionScreen.numRects = 1;
+  layer->visibleRegionScreen.rects = &layer->displayFrame;
+  layer->acquireFenceFd = -1;
+  layer->releaseFenceFd = -1;
+
+  list->retireFenceFd = -1;
+  list->flags = HWC_GEOMETRY_CHANGED;
+  list->numHwLayers = 2;
+
+  m_hwNativeWindow = new HWComposer(res.iWidth, res.iHeight, HAL_PIXEL_FORMAT_RGBA_8888, m_hwcDevicePtr, m_bufferList, &list->hwLayers[1]);
+  if (m_hwNativeWindow == NULL)
+  {
+    CLog::Log(LOGERROR, "HWComposer native window failed!");
+    return false;
+  }
+  m_swNativeWindow = (static_cast<ANativeWindow *> (m_hwNativeWindow));
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeHybris::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+
+  return true;
+}
+
+bool CEGLNativeTypeHybris::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+
+#if defined(TARGET_HYBRIS)
+  *nativeWindow = (XBNativeWindowType*) &m_swNativeWindow;
+  return (m_swNativeWindow != NULL);
+#else
+  return false;
+#endif
+}
+
+bool CEGLNativeTypeHybris::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeHybris::DestroyNativeWindow()
+{
+  m_nativeWindow = NULL;
+  return true;
+}
+
+bool CEGLNativeTypeHybris::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+#if defined(TARGET_HYBRIS)
+  uint32_t configs[5];
+  size_t numConfigs = 5;
+
+  int err = m_hwcDevicePtr->getDisplayConfigs(m_hwcDevicePtr, 0, configs, &numConfigs);
+  if (err) {
+      CLog::Log(LOGERROR, "getDisplayConfigs failed!");
+      return false;
+  }
+  int32_t attr_values[3];
+  uint32_t attributes[] = { HWC_DISPLAY_WIDTH, HWC_DISPLAY_HEIGHT, HWC_DISPLAY_VSYNC_PERIOD, HWC_DISPLAY_NO_ATTRIBUTE };
+
+  m_hwcDevicePtr->getDisplayAttributes(m_hwcDevicePtr, 0, configs[0], attributes, attr_values);
+
+  res->iWidth        = attr_values[0];
+  res->iHeight       = attr_values[1];
+  res->fRefreshRate  = 1000000000 / attr_values[2];
+
+  res->dwFlags       = D3DPRESENTFLAG_PROGRESSIVE;
+  res->iScreen       = 0;
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->iScreenWidth  = res->iWidth;
+  res->iScreenHeight = res->iHeight;
+  res->strMode       = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+  res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  CLog::Log(LOGNOTICE,"Current resolution: %s\n",res->strMode.c_str());
+  return true;
+#endif
+}
+
+bool CEGLNativeTypeHybris::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  return false;
+}
+
+bool CEGLNativeTypeHybris::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  RESOLUTION_INFO res;
+  if (GetNativeResolution(&res) && res.iWidth > 1 && res.iHeight > 1)
+  {
+    resolutions.push_back(res);
+    return true;
+  }
+  return false;
+}
+
+bool CEGLNativeTypeHybris::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  if (GetNativeResolution(res))
+    return true;
+  return false;
+}
+
+bool CEGLNativeTypeHybris::ShowWindow(bool show)
+{
+  return true;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeHybris.h b/xbmc/windowing/egl/EGLNativeTypeHybris.h
new file mode 100644
index 0000000..73aa14d
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeHybris.h
@@ -0,0 +1,77 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_HYBRIS)
+#include <hwcomposerwindow/hwcomposer_window.h>
+#include <hardware/hardware.h>
+#include <hardware/hwcomposer.h>
+#endif
+
+#include "EGLNativeType.h"
+#include "threads/Thread.h"
+
+class HWComposer : public HWComposerNativeWindow
+{
+  private:
+    hwc_layer_1_t *fblayer;
+    hwc_composer_device_1_t *hwcdevice;
+    hwc_display_contents_1_t **mlist;
+  protected:
+    void present(HWComposerNativeWindowBuffer *buffer);
+  public:
+    HWComposer(unsigned int width, unsigned int height, unsigned int format, hwc_composer_device_1_t *device, hwc_display_contents_1_t **mList, hwc_layer_1_t *layer);
+};
+
+class CEGLNativeTypeHybris : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeHybris();
+  virtual ~CEGLNativeTypeHybris();
+  virtual std::string GetNativeName() const { return "hybris"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return 0; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+#if defined(TARGET_HYBRIS)
+private:
+  hw_module_t                *m_hwcModule;
+  hwc_display_contents_1_t   **m_bufferList;
+  hwc_composer_device_1_t    *m_hwcDevicePtr;
+  HWComposerNativeWindow     *m_hwNativeWindow;
+  ANativeWindow              *m_swNativeWindow;
+#endif
+};
-- 
2.5.0


From 53b91e3a91fd717cda3534ed7cb998aa1c15cee3 Mon Sep 17 00:00:00 2001
From: "d.odintsov" <d.odintsov@traviangames.com>
Date: Mon, 18 Jan 2016 14:19:41 +0100
Subject: [PATCH 02/10] Initial commit transferring modifications from 15.2

---
 configure.ac                                       |  72 +++++++++--
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp        |  29 +++--
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |  32 +++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp  |   6 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in   |  10 +-
 xbmc/linux/Makefile.in                             |   1 +
 xbmc/utils/AMLUtils.cpp                            |  75 ++++++++++-
 xbmc/utils/CPUInfo.cpp                             |  27 ++--
 xbmc/windowing/X11/WinSystemX11.cpp                |   5 +-
 xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp        | 144 ++++++++++++++-------
 xbmc/windowing/egl/EGLNativeTypeAmlogic.h          |  17 ++-
 xbmc/windowing/egl/EGLWrapper.cpp                  |  11 +-
 xbmc/windowing/egl/Makefile.in                     |   4 +
 13 files changed, 339 insertions(+), 94 deletions(-)

diff --git a/configure.ac b/configure.ac
index 55e73b9..73436bc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -84,7 +84,7 @@ AC_DEFUN([XB_FIND_SONAME],
     for path in $gcc_lib_path $env_lib_path $host_lib_path; do
       lib=[`ls -- $path/lib$2.dylib 2>/dev/null`]
       if test x$lib != x; then
-        # we want the path/name that is embedded in the dylib 
+        # we want the path/name that is embedded in the dylib
         $1_FILENAME=[`otool -L $lib | grep -v lib$2.dylib | grep lib$2 | awk '{V=1; print $V}'`]
         $1_SONAME=[`basename $$1_FILENAME`]
       fi
@@ -222,6 +222,10 @@ libusb_disabled_udev_found="== libusb disabled. =="
 libcec_enabled="== libcec enabled. =="
 libcec_disabled="== libcec disabled. CEC adapter support will not be available. =="
 
+# Odroid stuff
+hybris_enabled="== Libhybris enabled. =="
+hybris_disabled="== Libhybris disabled. =="
+
 AC_ARG_WITH([ffmpeg],
   [AS_HELP_STRING([--with-ffmpeg],
   [ffmpeg options: auto (search pkg-config or auto build), force (always build ffmpeg), shared (link dynamically), path_to_ffmpeg [default=force]])],
@@ -407,7 +411,7 @@ AC_ARG_ENABLE([avahi],
   [disable Avahi support (default is enabled if libavahi-common and libavahi-client is found)])],
   [use_avahi=$enableval],
   [use_avahi=yes])
-  
+
   AC_ARG_ENABLE([mdnsembedded],
   [AS_HELP_STRING([--disable-mdnsembedded],
   [disable mDNSEmbedded support (default is auto)])],
@@ -513,7 +517,7 @@ AC_ARG_ENABLE([breakpad],
 
 AC_ARG_ENABLE([codec],
   [AS_HELP_STRING([--enable-codec],
-  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec, libstagefright and imxvpu)])],
+  [enable additional codecs from a list of comma separated names, (default is none, c1, mfc, choices are amcodec, libstagefright and imxvpu)])],
   [add_codecs=$enableval],
   [add_codecs=no])
 
@@ -524,6 +528,13 @@ AC_ARG_ENABLE([libav-compat],
   [use_libav_hacks=$enableval],
   [use_libav_hacks=no])
 
+# Odroid stuff
+AC_ARG_ENABLE([hybris],
+  [AS_HELP_STRING([--enable-hybris],
+  [enable use of Libhybris (default is no) 'Linux only'])],
+  [use_hybris=$enableval],
+  [use_hybris=no])
+
 ### End of external library options
 
 if test "x$host_vendor" != "xapple"; then
@@ -562,7 +573,7 @@ case $host in
      use_gles=yes
      use_optical_drive=no
      use_x11=no
-     build_shared_lib=yes    
+     build_shared_lib=yes
      ;;
   i*86*-linux-gnu*|i*86*-*-linux-uclibc*)
      target_platform=target_linux
@@ -811,7 +822,7 @@ elif test "$use_arch" = "arm"; then
   CFLAGS="$CFLAGS -mno-apcs-stack-check"
   CXXFLAGS="$CXXFLAGS -mno-apcs-stack-check"
   if test "$use_tegra" = "yes"; then
-    # Compile for ARMv7a architecture, need to test gcc for vfpv3-d16 support 
+    # Compile for ARMv7a architecture, need to test gcc for vfpv3-d16 support
     SAVE_CFLAGS="$CFLAGS"
     CFLAGS="-mfpu=vfpv3-d16"
     AC_COMPILE_IFELSE(
@@ -820,10 +831,10 @@ elif test "$use_arch" = "arm"; then
         CXXFLAGS="$CXXFLAGS -Wno-psabi -Wa,-march=armv7a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mthumb-interwork"
         use_cpu=cortex-a9],
       [ CFLAGS="$SAVE_CFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"
-        CXXFLAGS="$CXXFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"    
+        CXXFLAGS="$CXXFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"
         use_cpu=cortex-a8])
   else
-    if test "$use_neon" = "yes"; then 
+    if test "$use_neon" = "yes"; then
       CFLAGS="$CFLAGS -mfpu=neon -mvectorize-with-neon-quad"
       CXXFLAGS="$CXXFLAGS -mfpu=neon -mvectorize-with-neon-quad"
     fi
@@ -1388,7 +1399,7 @@ fi
 
 # touch skin
 use_touch_skin=no
-if [[ -f "addons/skin.re-touched/addon.xml" ]]; then 
+if [[ -f "addons/skin.re-touched/addon.xml" ]]; then
   use_touch_skin=yes
   USE_TOUCH_SKIN=1
   AC_DEFINE([HAS_TOUCH_SKIN], [1], [Whether to build the touch skin.])
@@ -1620,6 +1631,23 @@ else
   AC_MSG_NOTICE($libcap_disabled)
 fi
 
+# Odroid stuff
+if test "x$use_hybris" != "xno"; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_HYBRIS")
+  USE_HYBRIS=1;
+  AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
+  AC_DEFINE(HAS_HYBRIS, [1], [Define if supporting Hybris based systems])
+  PKG_CHECK_MODULES([HWCOMPOSEREGL],  [hwcomposer-egl >= 0.1],
+    [INCLUDES="$INCLUDES -I/usr/include/hybris $HWCOMPOSEREGL_CFLAGS"; LIBS="$LIBS $HWCOMPOSEREGL_LIBS"],
+    AC_MSG_ERROR($missing_library))
+  PKG_CHECK_MODULES([HYBRISEGL],  [hybris-egl-platform >= 0.1],
+    [INCLUDES="$INCLUDES $HYBRISEGL_CFLAGS"; LIBS="$LIBS $HYBRISEGL_LIBS"],
+    AC_MSG_ERROR($missing_library))
+  PKG_CHECK_MODULES([LIBHARDWARE],  [libhardware >= 0.1],
+    [INCLUDES="$INCLUDES $LIBHARDWARE_CFLAGS"; LIBS="$LIBS $LIBHARDWARE_LIBS -lsync -lmedia"],
+    AC_MSG_ERROR($missing_library))
+fi
+
 # FFmpeg
 FFMPEG_LIBNAMES="libavcodec >= 56.26.100
                  libavfilter >= 5.11.102
@@ -1705,7 +1733,7 @@ fi
 
 if test "$FFMPEG_FOUND" != "true"; then
   PKG_CHECK_MODULES([FFMPEG], [$FFMPEG_LIBNAMES],
-    [INCLUDES="$INCLUDES $FFMPEG_CFLAGS"; LIBS="$LIBS $FFMPEG_LIBS"; FFMPEG_FOUND="true"], 
+    [INCLUDES="$INCLUDES $FFMPEG_CFLAGS"; LIBS="$LIBS $FFMPEG_LIBS"; FFMPEG_FOUND="true"],
     [AC_MSG_ERROR("ffmpeg not found")])
 fi
 
@@ -1860,6 +1888,14 @@ esac
 # remember to convert commas to spaces
 for codecs in `echo $add_codecs | sed 's/,/ /g'`; do
   case $codecs in
+    *c1*)
+        AC_CHECK_HEADER([amcodec/codec.h],, AC_MSG_ERROR($missing_headers))
+        AC_CHECK_LIB([amcodec], main, LIBS="$LIBS -lamcodec -lamadec -lasound -lamavutils", AC_MSG_ERROR($missing_library))
+        XB_ADD_CODEC([C1], [c1], [$codecs])
+        ;;
+    *mfc*)
+        XB_ADD_CODEC([MFC], [mfc], [$codecs])
+        ;;
     *amcodec*)
         AC_CHECK_HEADER([amcodec/codec_error.h],, AC_MSG_ERROR($missing_headers))
         XB_ADD_CODEC([LIBAMCODEC], [amcodec], [$codecs])
@@ -2274,7 +2310,7 @@ else
 fi
 
 if test "x$use_airtunes" != "xno"; then
-  final_message="$final_message\n  AirTunes support (libshairplay):\tYes"  
+  final_message="$final_message\n  AirTunes support (libshairplay):\tYes"
 else
   final_message="$final_message\n  AirTunes support:\tNo"
 fi
@@ -2331,6 +2367,13 @@ else
   final_message="$final_message\n  additional codecs:\tNo"
 fi
 
+# Odroid stuff
+if test "x$use_hybris" != "xno"; then
+  final_message="$final_message\n  Odroid Hybris support:\tYes"
+else
+  final_message="$final_message\n  Odroid Hybris support:\tNo"
+fi
+
 ### External libraries messages
 
 if test "$host_vendor" = "apple" ; then
@@ -2535,6 +2578,7 @@ AC_SUBST(USE_SSE4)
 AC_SUBST(USE_MMAL)
 AC_SUBST(USE_X11)
 AC_SUBST(USE_BREAKPAD)
+AC_SUBST(USE_HYBRIS)
 
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
@@ -2594,7 +2638,7 @@ XB_CONFIG_MODULE([lib/libdvd/libdvdcss], [
     --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
     --host=$host_alias \
     --build=$build_alias \
-    --target=$target_alias \      
+    --target=$target_alias \
     --disable-doc \
     --enable-static \
     --with-pic
@@ -2606,7 +2650,7 @@ XB_CONFIG_MODULE([lib/libdvd/libdvdread], [
     --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
     --host=$host_alias \
     --build=$build_alias \
-    --target=$target_alias \      
+    --target=$target_alias \
     --enable-static \
     --disable-shared \
     --disable-strip \
@@ -2625,7 +2669,7 @@ XB_CONFIG_MODULE([lib/libdvd/libdvdnav], [
     --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
     --host=$host_alias \
     --build=$build_alias \
-    --target=$target_alias \      
+    --target=$target_alias \
     --enable-static \
     --disable-shared \
     --cc="$CC"
@@ -2637,7 +2681,7 @@ XB_CONFIG_MODULE([lib/cpluff], [
     --host=$host_alias \
     --build=$build_alias \
     --target=$target_alias CFLAGS="$CFLAGS" CC="$CC" CXX="$CXX" LDFLAGS="$LDFLAGS" LIBS=""
-    #LDFLAGS="$LDFLAGS -Wl,-read_only_relocs,suppress"    
+    #LDFLAGS="$LDFLAGS -Wl,-read_only_relocs,suppress"
 ], [0])
 
 XB_CONFIG_MODULE([lib/gtest], [
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index e22db7a..b354708 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -734,16 +734,16 @@ bool CAESinkALSA::InitializeHW(const ALSAConfig &inconfig, ALSAConfig &outconfig
   snd_pcm_hw_params_get_buffer_size_max(hw_params, &bufferSize);
   snd_pcm_hw_params_get_period_size_max(hw_params, &periodSize, NULL);
 
-  /* 
-   We want to make sure, that we have max 200 ms Buffer with 
+  /*
+   We want to make sure, that we have max 200 ms Buffer with
    a periodSize of approx 50 ms. Choosing a higher bufferSize
    will cause problems with menu sounds. Buffer will be increased
    after those are fixed.
   */
   periodSize  = std::min(periodSize, (snd_pcm_uframes_t) sampleRate / 20);
   bufferSize  = std::min(bufferSize, (snd_pcm_uframes_t) sampleRate / 5);
-  
-  /* 
+
+  /*
    According to upstream we should set buffer size first - so make sure it is always at least
    4x period size to not get underruns (some systems seem to have issues with only 2 periods)
   */
@@ -762,7 +762,7 @@ bool CAESinkALSA::InitializeHW(const ALSAConfig &inconfig, ALSAConfig &outconfig
     snd_pcm_hw_params_copy(hw_params_copy, hw_params); // restore working copy
     CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Request: Failed to limit periodSize to %lu", periodSizeMax);
   }
-  
+
   // first trying bufferSize, PeriodSize
   // for more info see here:
   // http://mailman.alsa-project.org/pipermail/alsa-devel/2009-September/021069.html
@@ -787,7 +787,7 @@ bool CAESinkALSA::InitializeHW(const ALSAConfig &inconfig, ALSAConfig &outconfig
       // try only periodSize
       periodSize = periodSizeTemp;
       snd_pcm_hw_params_copy(hw_params_copy, hw_params); // restore working copy
-      if(snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL) != 0 
+      if(snd_pcm_hw_params_set_period_size_near(m_pcm, hw_params_copy, &periodSize, NULL) != 0
         || snd_pcm_hw_params(m_pcm, hw_params_copy) != 0)
       {
         // try only BufferSize
@@ -809,7 +809,7 @@ bool CAESinkALSA::InitializeHW(const ALSAConfig &inconfig, ALSAConfig &outconfig
       snd_pcm_get_params(m_pcm, &bufferSize, &periodSize);
     }
   }
-  
+
   CLog::Log(LOGDEBUG, "CAESinkALSA::InitializeHW - Got: periodSize %lu, bufferSize %lu", periodSize, bufferSize);
 
   /* set the format parameters */
@@ -1291,6 +1291,15 @@ void CAESinkALSA::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
 
 AEDeviceType CAESinkALSA::AEDeviceTypeFromName(const std::string &name)
 {
+
+#if defined(HAS_LIBAMCODEC) || defined(HAS_C1)
+  // ugly workaround to show DTS / AC3 caps
+  // but don't run into multi channel issues
+  // as we can only open 2 pcm channels
+  // God, forgive me I wrote this
+  return AE_DEVTYPE_IEC958;
+#endif
+
   if (name.substr(0, 4) == "hdmi")
     return AE_DEVTYPE_HDMI;
   else if (name.substr(0, 6) == "iec958" || name.substr(0, 5) == "spdif")
@@ -1395,9 +1404,9 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
 
             if (badHDMI)
             {
-              /* 
-               * Warn about disconnected devices, but keep them enabled 
-               * Detection can go wrong on Intel, Nvidia and on all 
+              /*
+               * Warn about disconnected devices, but keep them enabled
+               * Detection can go wrong on Intel, Nvidia and on all
                * AMD (fglrx) hardware, so it is not safe to close those
                * handles
                */
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 84e9ef1..390d456 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -50,6 +50,12 @@
 #include "Video/DVDVideoCodecAndroidMediaCodec.h"
 #include "android/activity/AndroidFeatures.h"
 #endif
+#if defined(HAS_MFC)
+#include "Video/DVDVideoCodecMFC.h"
+#endif
+#if defined(HAS_C1)
+#include "Video/DVDVideoCodecC1.h"
+#endif
 #include "Audio/DVDAudioCodecFFmpeg.h"
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
@@ -199,6 +205,16 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, const C
 #else
   hwSupport += "MMAL:no ";
 #endif
+#if defined(HAS_MFC) && defined(_LINUX)
+  hwSupport += "MFC:yes ";
+#elif defined(_LINUX)
+  hwSupport += "MFC:no ";
+#endif
+#if defined(HAS_C1) && defined(_LINUX)
+  hwSupport += "C1:yes ";
+#elif defined(_LINUX)
+  hwSupport += "C1:no ";
+#endif
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
@@ -207,6 +223,22 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, const C
      if ( (pCodec = OpenCodec(new CDVDVideoCodecLibMpeg2(), hint, options)) ) return pCodec;
   }
 
+#if defined(HAS_MFC)
+  if ( !hint.software )
+  {
+    if ( hint.codec == AV_CODEC_ID_H263 || hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_MPEG4 || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_VC1 )
+      if( (pCodec = OpenCodec(new CDVDVideoCodecMFC(), hint, options)) ) return pCodec;
+  }
+#endif
+
+#if defined(HAS_C1)
+  if ( !hint.software )
+  {
+    if ( hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG4 || hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_HEVC )
+      if( (pCodec = OpenCodec(new CDVDVideoCodecC1(), hint, options)) ) return pCodec;
+  }
+#endif
+
 #if defined(HAS_LIBAMCODEC)
   // amcodec can handle dvd playback.
   if (!hint.software && CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEAMCODEC))
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
index 7236444..27f8e15 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
@@ -361,7 +361,7 @@ void dumpfile_write(am_private_t *para, void* buf, int bufsiz)
   }
 
   if (para->dumpdemux && para->dumpfile != -1)
-    write(para->dumpfile, buf, bufsiz);
+    int ret = write(para->dumpfile, buf, bufsiz);
 }
 
 /*************************************************************************/
@@ -714,7 +714,7 @@ int write_av_packet(am_private_t *para, am_packet_t *pkt)
         }
         pkt->newflag = 0;
     }
-	
+
     buf = pkt->data;
     size = pkt->data_size ;
     if (size == 0 && pkt->isvalid) {
@@ -1562,7 +1562,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamInfo &hints)
       // h264 in an avi file
       if (m_hints.ptsinvalid)
         am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
-      break; 
+      break;
     case VFORMAT_REAL:
       am_private->stream_type = AM_STREAM_RM;
       am_private->vcodec.noblock = 1;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 56ec6a3..12e2aad 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -41,8 +41,16 @@ ifeq (@USE_MMAL@,1)
 SRCS += MMALCodec.cpp
 endif
 
+ifeq (@USE_MFC@,1)
+SRCS += DVDVideoCodecMFC.cpp
+endif
+
+ifeq (@USE_C1@,1)
+SRCS += LinuxC1Codec.cpp
+SRCS += DVDVideoCodecC1.cpp
+endif
+
 LIB=Video.a
 
 include @abs_top_srcdir@/Makefile.include
 -include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
-
diff --git a/xbmc/linux/Makefile.in b/xbmc/linux/Makefile.in
index 744fd06..94ee9eb 100644
--- a/xbmc/linux/Makefile.in
+++ b/xbmc/linux/Makefile.in
@@ -12,6 +12,7 @@ SRCS += XFileUtils.cpp
 SRCS += XHandle.cpp
 SRCS += XMemUtils.cpp
 SRCS += XTimeUtils.cpp
+SRCS += LinuxV4l2Sink.cpp
 
 SRCS += RBP.cpp
 
diff --git a/xbmc/utils/AMLUtils.cpp b/xbmc/utils/AMLUtils.cpp
index 1b54435..8c06128 100644
--- a/xbmc/utils/AMLUtils.cpp
+++ b/xbmc/utils/AMLUtils.cpp
@@ -79,7 +79,7 @@ bool aml_wired_present()
 }
 
 bool aml_permissions()
-{  
+{
   if (!aml_present())
     return false;
 
@@ -348,6 +348,60 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 50;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p23hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 23.98;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p24hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 24;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p25hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 25;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p29hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 29.97;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p30hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 30;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p59hz")) // real
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 59.94;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
   else if (StringUtils::EqualsNoCase(fromMode, "720p") || StringUtils::EqualsNoCase(fromMode, "720p60hz"))
   {
     res->iWidth = 1280;
@@ -393,6 +447,24 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 24;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p25hz"))
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->fRefreshRate = 25;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p29hz")) // fake
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->fRefreshRate = 29.97;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
   else if (StringUtils::EqualsNoCase(fromMode, "1080p30hz"))
   {
     res->iWidth = 1920;
@@ -534,4 +606,3 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
 
   return res->iWidth > 0 && res->iHeight> 0;
 }
-
diff --git a/xbmc/utils/CPUInfo.cpp b/xbmc/utils/CPUInfo.cpp
index f1d07dd..fff9b80 100644
--- a/xbmc/utils/CPUInfo.cpp
+++ b/xbmc/utils/CPUInfo.cpp
@@ -117,7 +117,7 @@ CCPUInfo::CCPUInfo(void)
 #if defined(TARGET_DARWIN)
   size_t len = 4;
   std::string cpuVendor;
-  
+
   // The number of cores.
   if (sysctlbyname("hw.activecpu", &m_cpuCount, &len, NULL, 0) == -1)
       m_cpuCount = 1;
@@ -138,7 +138,7 @@ CCPUInfo::CCPUInfo(void)
   len = 512;
   if (sysctlbyname("machdep.cpu.vendor", &buffer, &len, NULL, 0) == 0)
     cpuVendor = buffer;
-  
+
 #endif
   // Go through each core.
   for (int i=0; i<m_cpuCount; i++)
@@ -221,7 +221,7 @@ CCPUInfo::CCPUInfo(void)
   }
   else
     m_cpuQueryFreq = NULL;
-  
+
   if (PdhOpenQueryW(NULL, 0, &m_cpuQueryLoad) == ERROR_SUCCESS)
   {
     for (size_t i = 0; i < m_cores.size(); i++)
@@ -263,9 +263,9 @@ CCPUInfo::CCPUInfo(void)
   if (m_fProcTemperature == NULL)
     m_fProcTemperature = fopen("/proc/acpi/thermal_zone/TZ0/temperature", "r");
   // read from the new location of the temperature data on new kernels, 2.6.39, 3.0 etc
-  if (m_fProcTemperature == NULL)   
+  if (m_fProcTemperature == NULL)
     m_fProcTemperature = fopen("/sys/class/hwmon/hwmon0/temp1_input", "r");
-  if (m_fProcTemperature == NULL)   
+  if (m_fProcTemperature == NULL)
     m_fProcTemperature = fopen("/sys/class/thermal/thermal_zone0/temp", "r");  // On Raspberry PIs
 
   m_fCPUFreq = fopen ("/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq", "r");
@@ -533,7 +533,7 @@ float CCPUInfo::getCPUFrequency()
       return float(cnt.FirstValue);
     }
   }
-  
+
   if (!m_cores.empty())
     return float(m_cores.begin()->second.m_fSpeed);
   else
@@ -579,7 +579,7 @@ bool CCPUInfo::getTemperature(CTemperature& temperature)
 {
   int         value = 0;
   char        scale = 0;
-  
+
 #ifdef TARGET_POSIX
 #if defined(TARGET_DARWIN_OSX)
   value = SMCGetTemperature(SMC_KEY_CPU_TEMP);
@@ -608,23 +608,24 @@ bool CCPUInfo::getTemperature(CTemperature& temperature)
     // procfs is deprecated in the linux kernel, we should move away from
     // using it for temperature data.  It doesn't seem that sysfs has a
     // general enough interface to bother implementing ATM.
-    
+
     rewind(m_fProcTemperature);
     fflush(m_fProcTemperature);
     ret = fscanf(m_fProcTemperature, "temperature: %d %c", &value, &scale);
-    
+
     // read from the temperature file of the new kernels
     if (!ret)
     {
       ret = fscanf(m_fProcTemperature, "%d", &value);
-      value = value / 1000;
+      if ((int)value > 1000)
+        value = value / 1000;
       scale = 'c';
       ret++;
     }
   }
 
   if (ret != 2)
-    return false; 
+    return false;
 #endif
 #endif // TARGET_POSIX
 
@@ -634,7 +635,7 @@ bool CCPUInfo::getTemperature(CTemperature& temperature)
     temperature = CTemperature::CreateFromFahrenheit(value);
   else
     return false;
-  
+
   return true;
 }
 
@@ -689,7 +690,7 @@ bool CCPUInfo::readProcStat(unsigned long long& user, unsigned long long& nice,
         const LONGLONG deltaTotal = coreTotal - curCore.m_total,
                        deltaIdle  = coreIdle - curCore.m_idle;
         const double load = (double(deltaTotal - deltaIdle) * 100.0) / double(deltaTotal);
-        
+
         // win32 has some problems with calculation of load if load close to zero
         curCore.m_fPct = (load < 0) ? 0 : load;
         if (load >= 0 || deltaTotal > 5 * 10 * 1000 * 1000) // do not update (smooth) values for 5 seconds on negative loads
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 134c498..4381591 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -253,7 +253,7 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     mode.hz  = CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
     mode.id  = CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP).strId;
   }
- 
+
   XMode   currmode = g_xrandr.GetCurrentMode(out.name);
   if (!currmode.name.empty())
   {
@@ -581,9 +581,10 @@ bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
     return false;
   if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_ALPHA_SIZE, &value) || value < 8)
     return false;
+/* Workaround for buggy Mali userspace library
   if (!eglGetConfigAttrib(m_eglDisplay, config, EGL_DEPTH_SIZE, &value) || value < 24)
     return false;
- 
+*/
 #endif
   return true;
 }
diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
index 21256ef..6c2a9a8 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
@@ -23,13 +23,18 @@
 #include "utils/AMLUtils.h"
 #include "utils/StringUtils.h"
 #include "utils/SysfsUtils.h"
+#include "utils/log.h"
 
-#include <stdio.h>
 #include <stdlib.h>
 #include <linux/fb.h>
 #include <sys/ioctl.h>
 #include <EGL/egl.h>
 
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CEGLNativeTypeAmlogic"
+
 CEGLNativeTypeAmlogic::CEGLNativeTypeAmlogic()
 {
   const char *env_framebuffer = getenv("FRAMEBUFFER");
@@ -64,7 +69,7 @@ bool CEGLNativeTypeAmlogic::CheckCompatibility()
 void CEGLNativeTypeAmlogic::Initialize()
 {
   aml_permissions();
-  DisableFreeScale();
+  FreeScale(false);
 }
 void CEGLNativeTypeAmlogic::Destroy()
 {
@@ -73,19 +78,24 @@ void CEGLNativeTypeAmlogic::Destroy()
 
 bool CEGLNativeTypeAmlogic::CreateNativeDisplay()
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   m_nativeDisplay = EGL_DEFAULT_DISPLAY;
   return true;
 }
 
 bool CEGLNativeTypeAmlogic::CreateNativeWindow()
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
 #if defined(_FBDEV_WINDOW_H_)
   fbdev_window *nativeWindow = new fbdev_window;
   if (!nativeWindow)
     return false;
 
-  nativeWindow->width = 1920;
-  nativeWindow->height = 1080;
+  RESOLUTION_INFO res;
+  GetPreferredResolution(&res);
+
+  nativeWindow->width = res.iWidth;
+  nativeWindow->height = res.iHeight;
   m_nativeWindow = nativeWindow;
 
   SetFramebufferResolution(nativeWindow->width, nativeWindow->height);
@@ -98,6 +108,7 @@ bool CEGLNativeTypeAmlogic::CreateNativeWindow()
 
 bool CEGLNativeTypeAmlogic::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   if (!nativeDisplay)
     return false;
   *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
@@ -106,6 +117,7 @@ bool CEGLNativeTypeAmlogic::GetNativeDisplay(XBNativeDisplayType **nativeDisplay
 
 bool CEGLNativeTypeAmlogic::GetNativeWindow(XBNativeWindowType **nativeWindow) const
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   if (!nativeWindow)
     return false;
   *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
@@ -114,11 +126,13 @@ bool CEGLNativeTypeAmlogic::GetNativeWindow(XBNativeWindowType **nativeWindow) c
 
 bool CEGLNativeTypeAmlogic::DestroyNativeDisplay()
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   return true;
 }
 
 bool CEGLNativeTypeAmlogic::DestroyNativeWindow()
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
 #if defined(_FBDEV_WINDOW_H_)
   delete (fbdev_window*)m_nativeWindow, m_nativeWindow = NULL;
 #endif
@@ -134,6 +148,7 @@ bool CEGLNativeTypeAmlogic::GetNativeResolution(RESOLUTION_INFO *res) const
 
 bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
 {
+  CLog::Log(LOGNOTICE, "%s::%s to %dx%d@%f", CLASSNAME, __func__, res.iScreenWidth, res.iScreenHeight, res.fRefreshRate);
 #if defined(_FBDEV_WINDOW_H_)
   if (m_nativeWindow)
   {
@@ -142,55 +157,103 @@ bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
   }
 #endif
 
-  switch((int)(0.5 + res.fRefreshRate))
+  bool result = false;
+
+  switch((int)(res.fRefreshRate))
   {
-    default:
-    case 60:
+    case 23:
+      switch(res.iScreenWidth)
+      {
+        case 1920:
+          result = SetDisplayResolution("1080p23hz");
+          break;
+      }
+      break;
+    case 24:
+      switch(res.iScreenWidth)
+      {
+        case 1920:
+          result = SetDisplayResolution("1080p24hz");
+          break;
+      }
+      break;
+    case 25:
+    case 50:
       switch(res.iScreenWidth)
       {
-        default:
         case 1280:
-          SetDisplayResolution("720p");
+          result = SetDisplayResolution("720p50hz");
           break;
         case 1920:
           if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
-            SetDisplayResolution("1080i");
+            result = SetDisplayResolution("1080i50hz");
           else
-            SetDisplayResolution("1080p");
+            result = SetDisplayResolution("1080p50hz");
           break;
       }
       break;
-    case 50:
+    case 29:
+    case 59:
       switch(res.iScreenWidth)
       {
-        default:
         case 1280:
-          SetDisplayResolution("720p50hz");
+          result = SetDisplayResolution("720p59hz");
           break;
         case 1920:
           if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
-            SetDisplayResolution("1080i50hz");
+            result = SetDisplayResolution("1080i59hz");
           else
-            SetDisplayResolution("1080p50hz");
+            result = SetDisplayResolution("1080p59hz");
           break;
       }
       break;
     case 30:
-      SetDisplayResolution("1080p30hz");
-      break;
-    case 24:
-      SetDisplayResolution("1080p24hz");
+    case 60:
+      switch(res.iScreenWidth)
+      {
+        default:
+        case 1280:
+          result = SetDisplayResolution("720p");
+          break;
+        case 1920:
+          if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
+            result = SetDisplayResolution("1080i");
+          else
+            result = SetDisplayResolution("1080p");
+          break;
+      }
       break;
   }
 
-  return true;
+  return result;
 }
 
 bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   std::string valstr;
   SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap", valstr);
-  std::vector<std::string> probe_str = StringUtils::Split(valstr, "\n");
+
+  std::vector<std::string> probe_str;
+  probe_str.push_back("720p23hz");  // fake
+  probe_str.push_back("720p24hz");  // fake
+  probe_str.push_back("720p25hz");  // fake
+  probe_str.push_back("720p29hz");  // fake
+  probe_str.push_back("720p30hz");  // fake
+  probe_str.push_back("720p50hz");  // real
+  probe_str.push_back("720p59hz");  // real
+  probe_str.push_back("720p");      // real
+  probe_str.push_back("1080p23hz"); // real
+  probe_str.push_back("1080p24hz"); // real
+  probe_str.push_back("1080p25hz"); // fake
+  probe_str.push_back("1080p29hz"); // fake
+  probe_str.push_back("1080p30hz"); // fake
+  probe_str.push_back("1080p50hz"); // real
+  probe_str.push_back("1080p59hz"); // real
+  probe_str.push_back("1080p");     // real
+  probe_str.push_back("1080i50hz"); // real
+  probe_str.push_back("1080i59hz"); // real
+  probe_str.push_back("1080i");     // real
 
   resolutions.clear();
   RESOLUTION_INFO res;
@@ -200,11 +263,11 @@ bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resol
       resolutions.push_back(res);
   }
   return resolutions.size() > 0;
-
 }
 
 bool CEGLNativeTypeAmlogic::GetPreferredResolution(RESOLUTION_INFO *res) const
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   // check display/mode, it gets defaulted at boot
   if (!GetNativeResolution(res))
   {
@@ -217,6 +280,7 @@ bool CEGLNativeTypeAmlogic::GetPreferredResolution(RESOLUTION_INFO *res) const
 
 bool CEGLNativeTypeAmlogic::ShowWindow(bool show)
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   std::string blank_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/blank";
   SysfsUtils::SetInt(blank_framebuffer.c_str(), show ? 0 : 1);
   return true;
@@ -224,6 +288,7 @@ bool CEGLNativeTypeAmlogic::ShowWindow(bool show)
 
 bool CEGLNativeTypeAmlogic::SetDisplayResolution(const char *resolution)
 {
+  CLog::Log(LOGNOTICE, "%s::%s to %s", CLASSNAME, __func__, resolution);
   std::string mode = resolution;
   // switch display resolution
   SysfsUtils::SetString("/sys/class/display/mode", mode.c_str());
@@ -235,32 +300,21 @@ bool CEGLNativeTypeAmlogic::SetDisplayResolution(const char *resolution)
   return true;
 }
 
-void CEGLNativeTypeAmlogic::SetupVideoScaling(const char *mode)
+void CEGLNativeTypeAmlogic::FreeScale(bool state)
 {
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/blank",      1);
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 0);
-  SysfsUtils::SetInt("/sys/class/ppmgr/ppscaler",          0);
-
-  if (strstr(mode, "1080"))
-  {
-    SysfsUtils::SetString("/sys/class/graphics/fb0/request2XScale", "8");
-    SysfsUtils::SetString("/sys/class/graphics/fb1/scale_axis",     "1280 720 1920 1080");
-    SysfsUtils::SetString("/sys/class/graphics/fb1/scale",          "0x10001");
-  }
-  else
-  {
-    SysfsUtils::SetString("/sys/class/graphics/fb0/request2XScale", "16 1280 720");
-  }
-
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/blank", 0);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  std::string freescale_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/free_scale";
+  SysfsUtils::SetInt(freescale_framebuffer.c_str(), state ? 1 : 0);
 }
 
-void CEGLNativeTypeAmlogic::DisableFreeScale()
+bool CEGLNativeTypeAmlogic::IsHdmiConnected() const
 {
-  // turn off frame buffer freescale
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 0);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  std::string hpd_state;
+  SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap", hpd_state);
+  StringUtils::Trim(hpd_state);
+  return hpd_state == "1";
 }
 
 void CEGLNativeTypeAmlogic::SetFramebufferResolution(const RESOLUTION_INFO &res) const
diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.h b/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
index 6867c38..6dd579e 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
@@ -21,6 +21,19 @@
  */
 
 #include "EGLNativeType.h"
+#include <linux/fb.h>
+
+#ifndef _FBDEV_WINDOW_H_
+// Define it right here, since some platforms doesn't has fbdev_window.h at all.
+// This will not make it fail on these platforms badly, since it will fail softly anyway on some other init steps.
+#define _FBDEV_WINDOW_H_
+typedef struct fbdev_window
+{
+  unsigned short width;
+  unsigned short height;
+} fbdev_window;
+#endif
+
 class CEGLNativeTypeAmlogic : public CEGLNativeType
 {
 public:
@@ -49,12 +62,12 @@ public:
 
 protected:
   bool SetDisplayResolution(const char *resolution);
-  void SetupVideoScaling(const char *mode);
-  void DisableFreeScale();
 
 private:
   void SetFramebufferResolution(const RESOLUTION_INFO &res) const;
   void SetFramebufferResolution(int width, int height) const;
+  void FreeScale(bool state);
+  bool IsHdmiConnected() const;
 
   std::string m_framebuffer_name;
 };
diff --git a/xbmc/windowing/egl/EGLWrapper.cpp b/xbmc/windowing/egl/EGLWrapper.cpp
index 036d4b9..b668c39 100644
--- a/xbmc/windowing/egl/EGLWrapper.cpp
+++ b/xbmc/windowing/egl/EGLWrapper.cpp
@@ -37,6 +37,10 @@
   #include "EGLNativeTypeIMX.h"
 #endif
 #include "EGLNativeTypeAmlogic.h"
+#ifdef HAS_HYBRIS
+#include "EGLNativeTypeHybris.h"
+#endif
+#include "EGLNativeTypeFbdev.h"
 #include "EGLWrapper.h"
 
 #define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
@@ -105,7 +109,11 @@ bool CEGLWrapper::Initialize(const std::string &implementation)
 #if defined(HAS_IMXVPU)
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation)) ||
 #endif
-      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAmlogic>(implementation))
+#ifdef HAS_HYBRIS
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeHybris>(implementation)) ||
+#endif
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAmlogic>(implementation)) ||
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeFbdev>(implementation))
       )
   {
     m_nativeTypes = nativeGuess;
@@ -431,4 +439,3 @@ bool CEGLWrapper::SurfaceAttrib(EGLDisplay display, EGLSurface surface, EGLint a
   return eglSurfaceAttrib(display, surface, attribute, value);
 }
 #endif
-
diff --git a/xbmc/windowing/egl/Makefile.in b/xbmc/windowing/egl/Makefile.in
index 32fb168..78d6b55 100644
--- a/xbmc/windowing/egl/Makefile.in
+++ b/xbmc/windowing/egl/Makefile.in
@@ -32,6 +32,10 @@ SRCS+= wayland/Callback.cpp \
        wayland/XBMCConnection.cpp \
        wayland/XBMCSurface.cpp
 endif
+ifeq (@USE_HYBRIS@,1)
+SRCS+= EGLNativeTypeHybris.cpp
+endif
+SRCS+= EGLNativeTypeFbdev.cpp
 
 LIB = windowing_egl.a
 
-- 
2.5.0


From e5472da49947f45a51acdc9cb241327a9658529f Mon Sep 17 00:00:00 2001
From: Owersun <owersun@gmail.com>
Date: Tue, 19 Jan 2016 08:12:00 +0100
Subject: [PATCH 03/10] C1: Make it compile

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp | 4 ++--
 xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp    | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp
index 3ce53f5..bbd3412 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp
@@ -115,8 +115,8 @@ bool CDVDVideoCodecC1::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
   if (m_hints.aspect > 0.0 && (((uint)lrint(m_videobuffer.iHeight * m_hints.aspect)) & -3) > m_videobuffer.iWidth)
       m_videobuffer.iDisplayWidth = ((int)lrint(m_videobuffer.iHeight * m_hints.aspect)) & -3;
   double scale = fmin(
-    (double)CDisplaySettings::Get().GetCurrentResolutionInfo().iWidth / (double)m_videobuffer.iDisplayWidth,
-    (double)CDisplaySettings::Get().GetCurrentResolutionInfo().iHeight / (double)m_videobuffer.iDisplayHeight
+    (double)CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iWidth / (double)m_videobuffer.iDisplayWidth,
+    (double)CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iHeight / (double)m_videobuffer.iDisplayHeight
   );
   m_videobuffer.iDisplayWidth = (int)((double)m_videobuffer.iDisplayWidth * scale);
   m_videobuffer.iDisplayHeight  = (int)((double)m_videobuffer.iDisplayHeight * scale);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
index 8f1525f..2c6eda7 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
@@ -892,8 +892,8 @@ void CLinuxC1Codec::SetViewport(int width, int height) {
 
   char setting[256] = {};
   double scale;
-  int displayWidth = CDisplaySettings::Get().GetCurrentResolutionInfo().iWidth;
-  int displayHeight = CDisplaySettings::Get().GetCurrentResolutionInfo().iHeight;
+  int displayWidth = CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iWidth;
+  int displayHeight = CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iHeight;
   int cutWidth;
   int cutHeight;
 
-- 
2.5.0


From b892db9e62b0571a37ef3b3711f4dfb29d19b574 Mon Sep 17 00:00:00 2001
From: Owersun <owersun@gmail.com>
Date: Sun, 7 Feb 2016 19:59:37 +0100
Subject: [PATCH 04/10] C2: forgotten bits

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
index 2c6eda7..83213f4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
@@ -659,7 +659,7 @@ bool CLinuxC1Codec::OpenDecoder(CDVDStreamInfo &hints) {
     default:
       break;
   }
-  am_private->gcodec.param = (void *)((unsigned int)am_private->gcodec.param | (am_private->video_rotation_degree << 16));
+  am_private->gcodec.param = (void *)((uintptr_t)am_private->gcodec.param | (am_private->video_rotation_degree << 16));
 
   // translate from generic to firmware version dependent
   codec_init_para(&am_private->gcodec, &am_private->vcodec);
-- 
2.5.0


From bc29c8588796acce48b2503744f5cbb1b99b4662 Mon Sep 17 00:00:00 2001
From: Owersun <owersun@gmail.com>
Date: Tue, 9 Feb 2016 21:08:57 +0100
Subject: [PATCH 05/10] No more memory corruption on exit

---
 xbmc/windowing/egl/EGLNativeTypeFbdev.cpp | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp b/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp
index 41ab866..5c25eb6 100644
--- a/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp
@@ -45,19 +45,6 @@ CEGLNativeTypeFbdev::CEGLNativeTypeFbdev()
 
 CEGLNativeTypeFbdev::~CEGLNativeTypeFbdev()
 {
-  if (m_nativeWindow)
-    free(m_nativeWindow);
-
-  if (vinfo)
-    free(vinfo);
-  if (finfo)
-    free(finfo);
-
-  if(m_iFBHandle >= 0)
-  {
-    close(m_iFBHandle);
-    m_iFBHandle = -1;
-  }
 }
 
 bool CEGLNativeTypeFbdev::CheckCompatibility()
-- 
2.5.0


From 3fee617eba08584b90d959001c9d7899de899b07 Mon Sep 17 00:00:00 2001
From: Owersun <owersun@gmail.com>
Date: Wed, 10 Feb 2016 20:42:51 +0100
Subject: [PATCH 06/10] C2: Frame rate automation

---
 xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
index 6c2a9a8..f83cd47 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
@@ -58,10 +58,12 @@ bool CEGLNativeTypeAmlogic::CheckCompatibility()
 {
   std::string name;
   std::string modalias = "/sys/class/graphics/" + m_framebuffer_name + "/device/modalias";
+  std::string meson = "meson";
+  std::string fb = "fb";
 
   SysfsUtils::GetString(modalias, name);
   StringUtils::Trim(name);
-  if (name == "platform:mesonfb")
+  if (name.find(meson) != std::string::npos && name.find(fb) != std::string::npos)
     return true;
   return false;
 }
-- 
2.5.0


From e5554b2ce94a6d37d31d37fe3aed11284cb01d10 Mon Sep 17 00:00:00 2001
From: Owersun <owersun@gmail.com>
Date: Mon, 14 Mar 2016 20:26:00 +0100
Subject: [PATCH 07/10] C2: 4k

---
 xbmc/utils/AMLUtils.cpp                     |  9 ++++++
 xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp | 50 ++++++++++++++++++++---------
 2 files changed, 44 insertions(+), 15 deletions(-)

diff --git a/xbmc/utils/AMLUtils.cpp b/xbmc/utils/AMLUtils.cpp
index 8c06128..33ee6cb 100644
--- a/xbmc/utils/AMLUtils.cpp
+++ b/xbmc/utils/AMLUtils.cpp
@@ -582,6 +582,15 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 50;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
+  else if (StringUtils::EqualsNoCase(fromMode, "4k2k59hz") || StringUtils::EqualsNoCase(fromMode, "2160p59hz"))
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 3840;
+    res->iScreenHeight= 2160;
+    res->fRefreshRate = 59.940;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
   else if (StringUtils::EqualsNoCase(fromMode, "2160p60hz420"))
   {
     res->iWidth = 1920;
diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
index f83cd47..9d47812 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
@@ -164,65 +164,80 @@ bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
   switch((int)(res.fRefreshRate))
   {
     case 23:
-      switch(res.iScreenWidth)
+      switch(res.iScreenHeight)
       {
-        case 1920:
+        case 1080:
           result = SetDisplayResolution("1080p23hz");
           break;
+        case 2160:
+          result = SetDisplayResolution("2160p23hz");
+          break;
       }
       break;
     case 24:
-      switch(res.iScreenWidth)
+      switch(res.iScreenHeight)
       {
-        case 1920:
+        case 1080:
           result = SetDisplayResolution("1080p24hz");
           break;
+        case 2160:
+          result = SetDisplayResolution("2160p24hz");
+          break;
       }
       break;
     case 25:
     case 50:
-      switch(res.iScreenWidth)
+      switch(res.iScreenHeight)
       {
-        case 1280:
+        case 720:
           result = SetDisplayResolution("720p50hz");
           break;
-        case 1920:
+        case 1080:
           if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
             result = SetDisplayResolution("1080i50hz");
           else
             result = SetDisplayResolution("1080p50hz");
           break;
+        case 2160:
+          result = SetDisplayResolution("2160p50hz420");
+          break;
       }
       break;
     case 29:
     case 59:
-      switch(res.iScreenWidth)
+      switch(res.iScreenHeight)
       {
-        case 1280:
+        case 720:
           result = SetDisplayResolution("720p59hz");
           break;
-        case 1920:
+        case 1080:
           if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
             result = SetDisplayResolution("1080i59hz");
           else
             result = SetDisplayResolution("1080p59hz");
           break;
+        case 2160:
+          result = SetDisplayResolution("2160p59hz");
+          break;
       }
       break;
     case 30:
     case 60:
-      switch(res.iScreenWidth)
+      switch(res.iScreenHeight)
       {
         default:
-        case 1280:
+        case 720:
           result = SetDisplayResolution("720p");
           break;
-        case 1920:
+        case 1080:
           if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
             result = SetDisplayResolution("1080i");
           else
             result = SetDisplayResolution("1080p");
           break;
+        case 2160:
+          result = SetDisplayResolution("2160p60hz420");
+          break;
       }
       break;
   }
@@ -256,6 +271,11 @@ bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resol
   probe_str.push_back("1080i50hz"); // real
   probe_str.push_back("1080i59hz"); // real
   probe_str.push_back("1080i");     // real
+  probe_str.push_back("2160p23hz");
+  probe_str.push_back("2160p24hz");
+  probe_str.push_back("2160p50hz420");
+  probe_str.push_back("2160p59hz");
+  probe_str.push_back("2160p60hz420");
 
   resolutions.clear();
   RESOLUTION_INFO res;
@@ -336,8 +356,8 @@ void CEGLNativeTypeAmlogic::SetFramebufferResolution(int width, int height) cons
     {
       vinfo.xres = width;
       vinfo.yres = height;
-      vinfo.xres_virtual = 1920;
-      vinfo.yres_virtual = 2160;
+      vinfo.xres_virtual = width;
+      vinfo.yres_virtual = height * 2;
       vinfo.bits_per_pixel = 32;
       vinfo.activate = FB_ACTIVATE_ALL;
       ioctl(fd0, FBIOPUT_VSCREENINFO, &vinfo);
-- 
2.5.0


From 93d6ac3c4aa0e25fbf0ca0b8cd6aad020e830164 Mon Sep 17 00:00:00 2001
From: Owersun <owersun@gmail.com>
Date: Sat, 19 Mar 2016 11:05:46 +0100
Subject: [PATCH 08/10] C2: 4k output support

---
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp | 21 ++++-------------
 xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp  | 10 ++++----
 .../dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp     |  4 ++--
 xbmc/utils/AMLUtils.cpp                            |  4 ++--
 xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp        | 27 ++++++++++++++++++----
 xbmc/windowing/egl/EGLNativeTypeAmlogic.h          |  2 ++
 6 files changed, 39 insertions(+), 29 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 390d456..7de9416 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -226,35 +226,22 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, const C
 #if defined(HAS_MFC)
   if ( !hint.software )
   {
-    if ( hint.codec == AV_CODEC_ID_H263 || hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_MPEG4 || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_VC1 )
-      if( (pCodec = OpenCodec(new CDVDVideoCodecMFC(), hint, options)) ) return pCodec;
+    if ( (pCodec = OpenCodec(new CDVDVideoCodecMFC(), hint, options)) ) return pCodec;
   }
 #endif
 
 #if defined(HAS_C1)
   if ( !hint.software )
   {
-    if ( hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG4 || hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_HEVC )
-      if( (pCodec = OpenCodec(new CDVDVideoCodecC1(), hint, options)) ) return pCodec;
+    if ( (pCodec = OpenCodec(new CDVDVideoCodecC1(), hint, options)) ) return pCodec;
   }
 #endif
 
 #if defined(HAS_LIBAMCODEC)
   // amcodec can handle dvd playback.
-  if (!hint.software && CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEAMCODEC))
+  if ( !hint.software )
   {
-    switch(hint.codec)
-    {
-      case AV_CODEC_ID_MPEG4:
-      case AV_CODEC_ID_MSMPEG4V2:
-      case AV_CODEC_ID_MSMPEG4V3:
-        // Avoid h/w decoder for SD; Those files might use features
-        // not supported and can easily be soft-decoded
-        if (hint.width <= 800)
-          break;
-      default:
-        if ( (pCodec = OpenCodec(new CDVDVideoCodecAmlogic(), hint, options)) ) return pCodec;
-    }
+    if ( (pCodec = OpenCodec(new CDVDVideoCodecAmlogic(), hint, options)) ) return pCodec;
   }
 #endif
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
index 27f8e15..61148c2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
@@ -387,13 +387,14 @@ static int64_t get_pts_video()
 
 static int set_pts_pcrscr(int64_t value)
 {
+  int ret;
   int fd = open("/sys/class/tsync/pts_pcrscr", O_WRONLY);
   if (fd >= 0)
   {
     char pts_str[64];
     unsigned long pts = (unsigned long)value;
     sprintf(pts_str, "0x%lx", pts);
-    write(fd, pts_str, strlen(pts_str));
+    ret = write(fd, pts_str, strlen(pts_str));
     close(fd);
     return 0;
   }
@@ -1630,7 +1631,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamInfo &hints)
   g_renderManager.RegisterRenderUpdateCallBack((const void*)this, RenderUpdateCallBack);
   g_renderManager.RegisterRenderFeaturesCallBack((const void*)this, RenderFeaturesCallBack);
 
-  m_display_rect = CRect(0, 0, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iWidth, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iHeight);
+  m_display_rect = CRect(0, 0, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenWidth, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenHeight);
 
   std::string strScaler;
   SysfsUtils::GetString("/sys/class/ppmgr/ppscaler", strScaler);
@@ -2186,7 +2187,6 @@ void CAMLCodec::SetVideoRect(const CRect &SrcRect, const CRect &DestRect)
         int diff = (int) ((dst_rect.Height() - dst_rect.Width()) / 2);
         dst_rect = CRect(DestRect.x1 - diff, DestRect.y1, DestRect.x2 + diff, DestRect.y2);
       }
-
   }
 
   if (m_dst_rect != dst_rect)
@@ -2208,7 +2208,7 @@ void CAMLCodec::SetVideoRect(const CRect &SrcRect, const CRect &DestRect)
 #ifdef TARGET_ANDROID
   display = m_display_rect;
 #else
-  display = gui;
+  display = CRect(0, 0, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenWidth, CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenHeight);;
 #endif
   if (gui != display)
   {
@@ -2280,6 +2280,8 @@ void CAMLCodec::SetVideoRect(const CRect &SrcRect, const CRect &DestRect)
   std::string s_gui = StringUtils::Format("%i,%i,%i,%i",
     (int)gui.x1, (int)gui.y1,
     (int)gui.Width(), (int)gui.Height());
+  CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:SrcRect(%i,%i,%i,%i)", (int)SrcRect.x1, (int)SrcRect.y1, (int)SrcRect.Width(), (int)SrcRect.Height());
+  CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:DestRect(%i,%i,%i,%i)", (int)DestRect.x1, (int)DestRect.y1, (int)DestRect.Width(), (int)DestRect.Height());
   CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:display(%s)", s_display.c_str());
   CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:gui(%s)", s_gui.c_str());
   CLog::Log(LOGDEBUG, "CAMLCodec::SetVideoRect:m_dst_rect(%s)", s_m_dst_rect.c_str());
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
index 83213f4..f6a1b35 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
@@ -892,8 +892,8 @@ void CLinuxC1Codec::SetViewport(int width, int height) {
 
   char setting[256] = {};
   double scale;
-  int displayWidth = CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iWidth;
-  int displayHeight = CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iHeight;
+  int displayWidth = CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenWidth;
+  int displayHeight = CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenHeight;
   int cutWidth;
   int cutHeight;
 
diff --git a/xbmc/utils/AMLUtils.cpp b/xbmc/utils/AMLUtils.cpp
index 33ee6cb..cd6d584 100644
--- a/xbmc/utils/AMLUtils.cpp
+++ b/xbmc/utils/AMLUtils.cpp
@@ -573,7 +573,7 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 30;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "2160p50hz420"))
+  else if (StringUtils::EqualsNoCase(fromMode, "2160p50hz"))
   {
     res->iWidth = 1920;
     res->iHeight= 1080;
@@ -591,7 +591,7 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 59.940;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "2160p60hz420"))
+  else if (StringUtils::EqualsNoCase(fromMode, "2160p60hz"))
   {
     res->iWidth = 1920;
     res->iHeight= 1080;
diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
index 9d47812..9dc4185 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
@@ -75,6 +75,7 @@ void CEGLNativeTypeAmlogic::Initialize()
 }
 void CEGLNativeTypeAmlogic::Destroy()
 {
+  SetScreenScale(1, 1, false);
   return;
 }
 
@@ -199,7 +200,7 @@ bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
             result = SetDisplayResolution("1080p50hz");
           break;
         case 2160:
-          result = SetDisplayResolution("2160p50hz420");
+          result = SetDisplayResolution("2160p50hz");
           break;
       }
       break;
@@ -236,12 +237,14 @@ bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
             result = SetDisplayResolution("1080p");
           break;
         case 2160:
-          result = SetDisplayResolution("2160p60hz420");
+          result = SetDisplayResolution("2160p60hz");
           break;
       }
       break;
   }
 
+  DealWithScale(res);
+
   return result;
 }
 
@@ -273,9 +276,9 @@ bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resol
   probe_str.push_back("1080i");     // real
   probe_str.push_back("2160p23hz");
   probe_str.push_back("2160p24hz");
-  probe_str.push_back("2160p50hz420");
+  probe_str.push_back("2160p50hz");
   probe_str.push_back("2160p59hz");
-  probe_str.push_back("2160p60hz420");
+  probe_str.push_back("2160p60hz");
 
   resolutions.clear();
   RESOLUTION_INFO res;
@@ -329,6 +332,22 @@ void CEGLNativeTypeAmlogic::FreeScale(bool state)
   SysfsUtils::SetInt(freescale_framebuffer.c_str(), state ? 1 : 0);
 }
 
+void CEGLNativeTypeAmlogic::DealWithScale(const RESOLUTION_INFO &res) {
+  CLog::Log(LOGDEBUG, "%s::%s Interface is %dx%d, screen size is %dx%d", CLASSNAME, __func__, res.iWidth, res.iHeight, res.iScreenWidth, res.iScreenHeight);
+  if (res.iScreenWidth > res.iWidth && res.iScreenHeight > res.iHeight) {
+    CLog::Log(LOGDEBUG, "%s::%s Scaling interfaces of size %dx%d to full screen", CLASSNAME, __func__, res.iWidth, res.iHeight);
+    SetScreenScale(res.iWidth, res.iHeight, true);
+  }
+}
+
+void CEGLNativeTypeAmlogic::SetScreenScale(int width, int height, bool state) {
+  char setting[256] = {};
+  sprintf(setting, "0 0 %d %d", width - 1 , height - 1);
+  std::string framebuffer = "/sys/class/graphics/" + m_framebuffer_name;
+  SysfsUtils::SetString(framebuffer + "/scale_axis", setting);
+  SysfsUtils::SetString(framebuffer + "/scale", state ? "0x10001" : "0x0");
+}
+
 bool CEGLNativeTypeAmlogic::IsHdmiConnected() const
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.h b/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
index 6dd579e..ca39273 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
@@ -67,6 +67,8 @@ private:
   void SetFramebufferResolution(const RESOLUTION_INFO &res) const;
   void SetFramebufferResolution(int width, int height) const;
   void FreeScale(bool state);
+  void DealWithScale(const RESOLUTION_INFO &res);
+  void SetScreenScale(int width, int height, bool state);
   bool IsHdmiConnected() const;
 
   std::string m_framebuffer_name;
-- 
2.5.0


From 6a93b1a936219fd10d33315168e27b8a20ccaf42 Mon Sep 17 00:00:00 2001
From: Owersun <owersun@gmail.com>
Date: Sun, 20 Mar 2016 10:29:58 +0100
Subject: [PATCH 09/10] C2: forgotten 4k resolutions

---
 xbmc/utils/AMLUtils.cpp                     | 5 +++--
 xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp | 3 +++
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/xbmc/utils/AMLUtils.cpp b/xbmc/utils/AMLUtils.cpp
index cd6d584..c4d42b2 100644
--- a/xbmc/utils/AMLUtils.cpp
+++ b/xbmc/utils/AMLUtils.cpp
@@ -195,7 +195,8 @@ bool aml_support_h264_4k2k()
 
 void aml_set_audio_passthrough(bool passthrough)
 {
-  SysfsUtils::SetInt("/sys/class/audiodsp/digital_raw", passthrough ? 2:0);
+  CLog::Log(LOGDEBUG, "AML: Setting passthrough %d", passthrough);
+  SysfsUtils::SetString("/sys/class/audiodsp/digital_raw", passthrough ? "2":"0");
 }
 
 void aml_probe_hdmi_audio()
@@ -213,7 +214,7 @@ void aml_probe_hdmi_audio()
   {
     char valstr[1024] = {0};
 
-    read(fd, valstr, sizeof(valstr) - 1);
+    int tmp = read(fd, valstr, sizeof(valstr) - 1);
     valstr[strlen(valstr)] = '\0';
     close(fd);
 
diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
index 9dc4185..2c5ca80 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
@@ -276,6 +276,9 @@ bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resol
   probe_str.push_back("1080i");     // real
   probe_str.push_back("2160p23hz");
   probe_str.push_back("2160p24hz");
+  probe_str.push_back("2160p25hz");
+  probe_str.push_back("2160p29hz");
+  probe_str.push_back("2160p30hz");
   probe_str.push_back("2160p50hz");
   probe_str.push_back("2160p59hz");
   probe_str.push_back("2160p60hz");
-- 
2.5.0


From f274ccaed9f748afb4a39593245d4932338ca685 Mon Sep 17 00:00:00 2001
From: Owersun <owersun@gmail.com>
Date: Fri, 25 Mar 2016 23:14:13 +0100
Subject: [PATCH 10/10] AML: More accurate resolution switch

---
 xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp | 213 +++++++++++++---------------
 1 file changed, 101 insertions(+), 112 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
index 2c5ca80..15a6429 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
@@ -73,6 +73,7 @@ void CEGLNativeTypeAmlogic::Initialize()
   aml_permissions();
   FreeScale(false);
 }
+
 void CEGLNativeTypeAmlogic::Destroy()
 {
   SetScreenScale(1, 1, false);
@@ -82,6 +83,7 @@ void CEGLNativeTypeAmlogic::Destroy()
 bool CEGLNativeTypeAmlogic::CreateNativeDisplay()
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
   m_nativeDisplay = EGL_DEFAULT_DISPLAY;
   return true;
 }
@@ -89,6 +91,7 @@ bool CEGLNativeTypeAmlogic::CreateNativeDisplay()
 bool CEGLNativeTypeAmlogic::CreateNativeWindow()
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
 #if defined(_FBDEV_WINDOW_H_)
   fbdev_window *nativeWindow = new fbdev_window;
   if (!nativeWindow)
@@ -112,6 +115,7 @@ bool CEGLNativeTypeAmlogic::CreateNativeWindow()
 bool CEGLNativeTypeAmlogic::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
   if (!nativeDisplay)
     return false;
   *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
@@ -121,6 +125,7 @@ bool CEGLNativeTypeAmlogic::GetNativeDisplay(XBNativeDisplayType **nativeDisplay
 bool CEGLNativeTypeAmlogic::GetNativeWindow(XBNativeWindowType **nativeWindow) const
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
   if (!nativeWindow)
     return false;
   *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
@@ -130,12 +135,14 @@ bool CEGLNativeTypeAmlogic::GetNativeWindow(XBNativeWindowType **nativeWindow) c
 bool CEGLNativeTypeAmlogic::DestroyNativeDisplay()
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
   return true;
 }
 
 bool CEGLNativeTypeAmlogic::DestroyNativeWindow()
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
 #if defined(_FBDEV_WINDOW_H_)
   delete (fbdev_window*)m_nativeWindow, m_nativeWindow = NULL;
 #endif
@@ -152,6 +159,7 @@ bool CEGLNativeTypeAmlogic::GetNativeResolution(RESOLUTION_INFO *res) const
 bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
 {
   CLog::Log(LOGNOTICE, "%s::%s to %dx%d@%f", CLASSNAME, __func__, res.iScreenWidth, res.iScreenHeight, res.fRefreshRate);
+
 #if defined(_FBDEV_WINDOW_H_)
   if (m_nativeWindow)
   {
@@ -161,86 +169,87 @@ bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
 #endif
 
   bool result = false;
-
-  switch((int)(res.fRefreshRate))
-  {
-    case 23:
-      switch(res.iScreenHeight)
-      {
-        case 1080:
-          result = SetDisplayResolution("1080p23hz");
-          break;
-        case 2160:
-          result = SetDisplayResolution("2160p23hz");
-          break;
-      }
-      break;
-    case 24:
-      switch(res.iScreenHeight)
-      {
-        case 1080:
-          result = SetDisplayResolution("1080p24hz");
-          break;
-        case 2160:
-          result = SetDisplayResolution("2160p24hz");
-          break;
-      }
-      break;
-    case 25:
-    case 50:
-      switch(res.iScreenHeight)
-      {
-        case 720:
-          result = SetDisplayResolution("720p50hz");
-          break;
-        case 1080:
-          if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
-            result = SetDisplayResolution("1080i50hz");
-          else
-            result = SetDisplayResolution("1080p50hz");
-          break;
-        case 2160:
-          result = SetDisplayResolution("2160p50hz");
-          break;
-      }
-      break;
-    case 29:
-    case 59:
-      switch(res.iScreenHeight)
-      {
-        case 720:
-          result = SetDisplayResolution("720p59hz");
-          break;
-        case 1080:
-          if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
-            result = SetDisplayResolution("1080i59hz");
-          else
-            result = SetDisplayResolution("1080p59hz");
-          break;
-        case 2160:
-          result = SetDisplayResolution("2160p59hz");
-          break;
-      }
-      break;
-    case 30:
-    case 60:
-      switch(res.iScreenHeight)
-      {
-        default:
-        case 720:
-          result = SetDisplayResolution("720p");
-          break;
-        case 1080:
-          if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
-            result = SetDisplayResolution("1080i");
-          else
-            result = SetDisplayResolution("1080p");
-          break;
-        case 2160:
-          result = SetDisplayResolution("2160p60hz");
-          break;
-      }
-      break;
+  int refreshRate = (int)(res.fRefreshRate);
+
+  switch (res.iScreenHeight) {
+      case 720:
+        switch(refreshRate) {
+          case 23:
+            result = SetDisplayResolution("720p23hz");
+            break;
+          case 24:
+            result = SetDisplayResolution("720p24hz");
+            break;
+          case 25:
+          case 50:
+            result = SetDisplayResolution("720p50hz");
+            break;
+          case 29:
+          case 59:
+            result = SetDisplayResolution("720p59hz");
+            break;
+          case 30:
+          case 60:
+            result = SetDisplayResolution("720p60hz");
+            break;
+        }
+        break;
+      case 1080:
+        switch(refreshRate) {
+          case 23:
+            result = SetDisplayResolution("1080p23hz");
+            break;
+          case 24:
+            result = SetDisplayResolution("1080p24hz");
+            break;
+          case 25:
+          case 50:
+            if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
+              result = SetDisplayResolution("1080i50hz");
+            else
+              result = SetDisplayResolution("1080p50hz");
+            break;
+          case 29:
+          case 59:
+            if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
+              result = SetDisplayResolution("1080i59hz");
+            else
+              result = SetDisplayResolution("1080p59hz");
+            break;
+          case 30:
+          case 60:
+            if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
+              result = SetDisplayResolution("1080i60hz");
+            else
+              result = SetDisplayResolution("1080p60hz");
+            break;
+        }
+        break;
+      case 2160:
+        switch(refreshRate) {
+          case 23:
+            result = SetDisplayResolution("2160p23hz");
+            break;
+          case 24:
+            result = SetDisplayResolution("2160p24hz");
+            break;
+          case 25:
+            result = SetDisplayResolution("2160p25hz");
+            break;
+          case 29:
+            result = SetDisplayResolution("2160p29hz");
+            break;
+          case 30:
+            result = SetDisplayResolution("2160p30hz");
+            break;
+          case 59:
+            result = SetDisplayResolution("2160p59hz");
+            break;
+          case 60:
+            result = SetDisplayResolution("2160p60hz");
+            break;
+        }
+        break;
   }
 
   DealWithScale(res);
@@ -251,37 +260,10 @@ bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
 bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
   std::string valstr;
   SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap", valstr);
-
-  std::vector<std::string> probe_str;
-  probe_str.push_back("720p23hz");  // fake
-  probe_str.push_back("720p24hz");  // fake
-  probe_str.push_back("720p25hz");  // fake
-  probe_str.push_back("720p29hz");  // fake
-  probe_str.push_back("720p30hz");  // fake
-  probe_str.push_back("720p50hz");  // real
-  probe_str.push_back("720p59hz");  // real
-  probe_str.push_back("720p");      // real
-  probe_str.push_back("1080p23hz"); // real
-  probe_str.push_back("1080p24hz"); // real
-  probe_str.push_back("1080p25hz"); // fake
-  probe_str.push_back("1080p29hz"); // fake
-  probe_str.push_back("1080p30hz"); // fake
-  probe_str.push_back("1080p50hz"); // real
-  probe_str.push_back("1080p59hz"); // real
-  probe_str.push_back("1080p");     // real
-  probe_str.push_back("1080i50hz"); // real
-  probe_str.push_back("1080i59hz"); // real
-  probe_str.push_back("1080i");     // real
-  probe_str.push_back("2160p23hz");
-  probe_str.push_back("2160p24hz");
-  probe_str.push_back("2160p25hz");
-  probe_str.push_back("2160p29hz");
-  probe_str.push_back("2160p30hz");
-  probe_str.push_back("2160p50hz");
-  probe_str.push_back("2160p59hz");
-  probe_str.push_back("2160p60hz");
+  std::vector<std::string> probe_str = StringUtils::Split(valstr, "\n");
 
   resolutions.clear();
   RESOLUTION_INFO res;
@@ -296,6 +278,7 @@ bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resol
 bool CEGLNativeTypeAmlogic::GetPreferredResolution(RESOLUTION_INFO *res) const
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
   // check display/mode, it gets defaulted at boot
   if (!GetNativeResolution(res))
   {
@@ -309,6 +292,7 @@ bool CEGLNativeTypeAmlogic::GetPreferredResolution(RESOLUTION_INFO *res) const
 bool CEGLNativeTypeAmlogic::ShowWindow(bool show)
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
   std::string blank_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/blank";
   SysfsUtils::SetInt(blank_framebuffer.c_str(), show ? 0 : 1);
   return true;
@@ -317,6 +301,7 @@ bool CEGLNativeTypeAmlogic::ShowWindow(bool show)
 bool CEGLNativeTypeAmlogic::SetDisplayResolution(const char *resolution)
 {
   CLog::Log(LOGNOTICE, "%s::%s to %s", CLASSNAME, __func__, resolution);
+
   std::string mode = resolution;
   // switch display resolution
   SysfsUtils::SetString("/sys/class/display/mode", mode.c_str());
@@ -331,19 +316,23 @@ bool CEGLNativeTypeAmlogic::SetDisplayResolution(const char *resolution)
 void CEGLNativeTypeAmlogic::FreeScale(bool state)
 {
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
   std::string freescale_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/free_scale";
   SysfsUtils::SetInt(freescale_framebuffer.c_str(), state ? 1 : 0);
 }
 
-void CEGLNativeTypeAmlogic::DealWithScale(const RESOLUTION_INFO &res) {
+void CEGLNativeTypeAmlogic::DealWithScale(const RESOLUTION_INFO &res)
+{
   CLog::Log(LOGDEBUG, "%s::%s Interface is %dx%d, screen size is %dx%d", CLASSNAME, __func__, res.iWidth, res.iHeight, res.iScreenWidth, res.iScreenHeight);
+
   if (res.iScreenWidth > res.iWidth && res.iScreenHeight > res.iHeight) {
-    CLog::Log(LOGDEBUG, "%s::%s Scaling interfaces of size %dx%d to full screen", CLASSNAME, __func__, res.iWidth, res.iHeight);
+    CLog::Log(LOGNOTICE, "%s::%s Scaling interfaces of size %dx%d to full screen", CLASSNAME, __func__, res.iWidth, res.iHeight);
     SetScreenScale(res.iWidth, res.iHeight, true);
   }
 }
 
-void CEGLNativeTypeAmlogic::SetScreenScale(int width, int height, bool state) {
+void CEGLNativeTypeAmlogic::SetScreenScale(int width, int height, bool state)
+{
   char setting[256] = {};
   sprintf(setting, "0 0 %d %d", width - 1 , height - 1);
   std::string framebuffer = "/sys/class/graphics/" + m_framebuffer_name;
-- 
2.5.0

